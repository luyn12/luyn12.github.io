<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java面试题 | luyn12&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/whale.ico">
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.d930c39a.css" as="style"><link rel="preload" href="/assets/js/app.9ad9824d.js" as="script"><link rel="preload" href="/assets/js/2.84b87111.js" as="script"><link rel="preload" href="/assets/js/107.0e050a3c.js" as="script"><link rel="prefetch" href="/assets/js/10.bbaa689f.js"><link rel="prefetch" href="/assets/js/100.da6b33bb.js"><link rel="prefetch" href="/assets/js/101.994dfe46.js"><link rel="prefetch" href="/assets/js/102.25718fbf.js"><link rel="prefetch" href="/assets/js/103.d664ec74.js"><link rel="prefetch" href="/assets/js/104.170041a7.js"><link rel="prefetch" href="/assets/js/105.2345e6ae.js"><link rel="prefetch" href="/assets/js/106.cab6dcfd.js"><link rel="prefetch" href="/assets/js/108.f18956e9.js"><link rel="prefetch" href="/assets/js/109.e76f9334.js"><link rel="prefetch" href="/assets/js/11.6661b2e2.js"><link rel="prefetch" href="/assets/js/110.6fdce98c.js"><link rel="prefetch" href="/assets/js/111.743d935b.js"><link rel="prefetch" href="/assets/js/112.67c8c25f.js"><link rel="prefetch" href="/assets/js/113.abc6b80d.js"><link rel="prefetch" href="/assets/js/114.d0a53d54.js"><link rel="prefetch" href="/assets/js/115.0ded3065.js"><link rel="prefetch" href="/assets/js/116.ea5b7c05.js"><link rel="prefetch" href="/assets/js/117.7ed2eec1.js"><link rel="prefetch" href="/assets/js/118.b3270d85.js"><link rel="prefetch" href="/assets/js/119.d4e894d7.js"><link rel="prefetch" href="/assets/js/12.c69dab5f.js"><link rel="prefetch" href="/assets/js/120.36e4f950.js"><link rel="prefetch" href="/assets/js/121.593b93ce.js"><link rel="prefetch" href="/assets/js/122.327a7d6a.js"><link rel="prefetch" href="/assets/js/123.d4d80970.js"><link rel="prefetch" href="/assets/js/124.2cdea51e.js"><link rel="prefetch" href="/assets/js/125.95c3af1a.js"><link rel="prefetch" href="/assets/js/126.2563add4.js"><link rel="prefetch" href="/assets/js/127.4e618ea2.js"><link rel="prefetch" href="/assets/js/128.1214f14c.js"><link rel="prefetch" href="/assets/js/129.08d3ed24.js"><link rel="prefetch" href="/assets/js/13.7ca6a5e0.js"><link rel="prefetch" href="/assets/js/130.4d0b168b.js"><link rel="prefetch" href="/assets/js/131.2802fff0.js"><link rel="prefetch" href="/assets/js/132.a6092483.js"><link rel="prefetch" href="/assets/js/133.e0678ec0.js"><link rel="prefetch" href="/assets/js/134.aeb0ec0d.js"><link rel="prefetch" href="/assets/js/135.013490db.js"><link rel="prefetch" href="/assets/js/136.16ec4ca8.js"><link rel="prefetch" href="/assets/js/137.e31a2bf6.js"><link rel="prefetch" href="/assets/js/138.d7b73d04.js"><link rel="prefetch" href="/assets/js/139.3ff62e7c.js"><link rel="prefetch" href="/assets/js/14.0410b688.js"><link rel="prefetch" href="/assets/js/140.f500185a.js"><link rel="prefetch" href="/assets/js/141.b63bfae3.js"><link rel="prefetch" href="/assets/js/142.5b480339.js"><link rel="prefetch" href="/assets/js/143.137750a6.js"><link rel="prefetch" href="/assets/js/144.f8440791.js"><link rel="prefetch" href="/assets/js/145.22b446a3.js"><link rel="prefetch" href="/assets/js/146.62b688d2.js"><link rel="prefetch" href="/assets/js/147.1f9479bf.js"><link rel="prefetch" href="/assets/js/148.59e31a7c.js"><link rel="prefetch" href="/assets/js/149.bf07dbf7.js"><link rel="prefetch" href="/assets/js/15.4e575f9d.js"><link rel="prefetch" href="/assets/js/150.e845e0b2.js"><link rel="prefetch" href="/assets/js/151.6cd6d641.js"><link rel="prefetch" href="/assets/js/152.dcbd4973.js"><link rel="prefetch" href="/assets/js/153.72bc2aac.js"><link rel="prefetch" href="/assets/js/154.b695fe3e.js"><link rel="prefetch" href="/assets/js/155.948169e9.js"><link rel="prefetch" href="/assets/js/156.4241b775.js"><link rel="prefetch" href="/assets/js/157.9c40d1f7.js"><link rel="prefetch" href="/assets/js/158.6218411d.js"><link rel="prefetch" href="/assets/js/159.45ac8f23.js"><link rel="prefetch" href="/assets/js/16.ae2ce703.js"><link rel="prefetch" href="/assets/js/160.31cbcce4.js"><link rel="prefetch" href="/assets/js/161.5310fddc.js"><link rel="prefetch" href="/assets/js/162.9ffd8cc5.js"><link rel="prefetch" href="/assets/js/163.8fe8b4cf.js"><link rel="prefetch" href="/assets/js/164.aeea12ba.js"><link rel="prefetch" href="/assets/js/165.8cc0a947.js"><link rel="prefetch" href="/assets/js/166.1637470b.js"><link rel="prefetch" href="/assets/js/167.8c923e8d.js"><link rel="prefetch" href="/assets/js/168.c4a0df12.js"><link rel="prefetch" href="/assets/js/169.8ade4f5c.js"><link rel="prefetch" href="/assets/js/17.23bad3c1.js"><link rel="prefetch" href="/assets/js/170.f110e534.js"><link rel="prefetch" href="/assets/js/171.9c33595c.js"><link rel="prefetch" href="/assets/js/172.d5668713.js"><link rel="prefetch" href="/assets/js/173.7e64bf4a.js"><link rel="prefetch" href="/assets/js/174.4b73564c.js"><link rel="prefetch" href="/assets/js/175.ddfc589d.js"><link rel="prefetch" href="/assets/js/176.66ab90bf.js"><link rel="prefetch" href="/assets/js/177.290d3d7c.js"><link rel="prefetch" href="/assets/js/178.b6c776b0.js"><link rel="prefetch" href="/assets/js/179.3db7f8b1.js"><link rel="prefetch" href="/assets/js/18.6eac2edf.js"><link rel="prefetch" href="/assets/js/180.36a34274.js"><link rel="prefetch" href="/assets/js/181.01bca25a.js"><link rel="prefetch" href="/assets/js/182.c2f4badc.js"><link rel="prefetch" href="/assets/js/183.477f2e01.js"><link rel="prefetch" href="/assets/js/184.9971cc03.js"><link rel="prefetch" href="/assets/js/185.dcec684a.js"><link rel="prefetch" href="/assets/js/186.78587e08.js"><link rel="prefetch" href="/assets/js/187.960cbe32.js"><link rel="prefetch" href="/assets/js/188.a3a6222a.js"><link rel="prefetch" href="/assets/js/189.ffd67911.js"><link rel="prefetch" href="/assets/js/19.884eb0e4.js"><link rel="prefetch" href="/assets/js/190.48cf9629.js"><link rel="prefetch" href="/assets/js/191.06231311.js"><link rel="prefetch" href="/assets/js/192.90f0ee7d.js"><link rel="prefetch" href="/assets/js/193.19a0e84e.js"><link rel="prefetch" href="/assets/js/194.e405c2ea.js"><link rel="prefetch" href="/assets/js/195.2a0f7ea7.js"><link rel="prefetch" href="/assets/js/196.a303bab3.js"><link rel="prefetch" href="/assets/js/197.b9470eda.js"><link rel="prefetch" href="/assets/js/198.c5095fc7.js"><link rel="prefetch" href="/assets/js/199.b4e49c75.js"><link rel="prefetch" href="/assets/js/20.6dc59aba.js"><link rel="prefetch" href="/assets/js/200.fe8fa6a3.js"><link rel="prefetch" href="/assets/js/201.be591e20.js"><link rel="prefetch" href="/assets/js/202.a84eaaf7.js"><link rel="prefetch" href="/assets/js/203.fcdd2799.js"><link rel="prefetch" href="/assets/js/204.d7d381d4.js"><link rel="prefetch" href="/assets/js/205.768754c7.js"><link rel="prefetch" href="/assets/js/206.b735f98e.js"><link rel="prefetch" href="/assets/js/207.dca384bc.js"><link rel="prefetch" href="/assets/js/208.5ce4d120.js"><link rel="prefetch" href="/assets/js/209.1ffd73c3.js"><link rel="prefetch" href="/assets/js/21.77b5633c.js"><link rel="prefetch" href="/assets/js/210.0aff8c0d.js"><link rel="prefetch" href="/assets/js/211.7df9a372.js"><link rel="prefetch" href="/assets/js/212.6e38a84d.js"><link rel="prefetch" href="/assets/js/213.98e8c888.js"><link rel="prefetch" href="/assets/js/214.b5c6f646.js"><link rel="prefetch" href="/assets/js/215.59ce910b.js"><link rel="prefetch" href="/assets/js/216.1d099076.js"><link rel="prefetch" href="/assets/js/217.fc497263.js"><link rel="prefetch" href="/assets/js/218.c5c2b2cd.js"><link rel="prefetch" href="/assets/js/219.11134840.js"><link rel="prefetch" href="/assets/js/22.e862de44.js"><link rel="prefetch" href="/assets/js/220.750c9114.js"><link rel="prefetch" href="/assets/js/221.08dbe338.js"><link rel="prefetch" href="/assets/js/222.6bf01e3c.js"><link rel="prefetch" href="/assets/js/223.a33b6cec.js"><link rel="prefetch" href="/assets/js/224.1e1e59d5.js"><link rel="prefetch" href="/assets/js/225.90b0329e.js"><link rel="prefetch" href="/assets/js/226.bb95565d.js"><link rel="prefetch" href="/assets/js/227.a43691bd.js"><link rel="prefetch" href="/assets/js/228.878a3025.js"><link rel="prefetch" href="/assets/js/229.459fea31.js"><link rel="prefetch" href="/assets/js/23.0ccdc315.js"><link rel="prefetch" href="/assets/js/230.da103ec8.js"><link rel="prefetch" href="/assets/js/231.e352b7fc.js"><link rel="prefetch" href="/assets/js/232.736a8205.js"><link rel="prefetch" href="/assets/js/233.774c02d0.js"><link rel="prefetch" href="/assets/js/234.3e576121.js"><link rel="prefetch" href="/assets/js/235.3eba4f76.js"><link rel="prefetch" href="/assets/js/236.d7374b5a.js"><link rel="prefetch" href="/assets/js/237.48b06d73.js"><link rel="prefetch" href="/assets/js/238.f784c286.js"><link rel="prefetch" href="/assets/js/239.6660648f.js"><link rel="prefetch" href="/assets/js/24.1941d660.js"><link rel="prefetch" href="/assets/js/240.1e8cd741.js"><link rel="prefetch" href="/assets/js/241.2058cdcb.js"><link rel="prefetch" href="/assets/js/242.e4c76ed2.js"><link rel="prefetch" href="/assets/js/243.e46c5cc2.js"><link rel="prefetch" href="/assets/js/244.63020353.js"><link rel="prefetch" href="/assets/js/245.de330cb6.js"><link rel="prefetch" href="/assets/js/246.0c8b2793.js"><link rel="prefetch" href="/assets/js/247.ca396f20.js"><link rel="prefetch" href="/assets/js/248.a8710b27.js"><link rel="prefetch" href="/assets/js/249.3ca11d6f.js"><link rel="prefetch" href="/assets/js/25.3c2611e8.js"><link rel="prefetch" href="/assets/js/250.f9430ba2.js"><link rel="prefetch" href="/assets/js/251.d932eef8.js"><link rel="prefetch" href="/assets/js/252.377c93b1.js"><link rel="prefetch" href="/assets/js/253.76fcc582.js"><link rel="prefetch" href="/assets/js/254.e1b2b1bd.js"><link rel="prefetch" href="/assets/js/255.5ba9b28a.js"><link rel="prefetch" href="/assets/js/256.7517a13c.js"><link rel="prefetch" href="/assets/js/257.3707cdd2.js"><link rel="prefetch" href="/assets/js/258.64da1c0d.js"><link rel="prefetch" href="/assets/js/259.04e4f4ba.js"><link rel="prefetch" href="/assets/js/26.3b6dedeb.js"><link rel="prefetch" href="/assets/js/260.f31743a3.js"><link rel="prefetch" href="/assets/js/261.ca5412f9.js"><link rel="prefetch" href="/assets/js/262.f2f8ac8f.js"><link rel="prefetch" href="/assets/js/27.1827822e.js"><link rel="prefetch" href="/assets/js/28.6cd91042.js"><link rel="prefetch" href="/assets/js/29.9d704db0.js"><link rel="prefetch" href="/assets/js/3.127acb4a.js"><link rel="prefetch" href="/assets/js/30.ccda2382.js"><link rel="prefetch" href="/assets/js/31.6efa9919.js"><link rel="prefetch" href="/assets/js/32.bf6cb2fa.js"><link rel="prefetch" href="/assets/js/33.9e3fa89f.js"><link rel="prefetch" href="/assets/js/34.3cca68cd.js"><link rel="prefetch" href="/assets/js/35.0edad1e4.js"><link rel="prefetch" href="/assets/js/36.06024936.js"><link rel="prefetch" href="/assets/js/37.316a0f20.js"><link rel="prefetch" href="/assets/js/38.93f3dac6.js"><link rel="prefetch" href="/assets/js/39.0183d662.js"><link rel="prefetch" href="/assets/js/4.8eefd89f.js"><link rel="prefetch" href="/assets/js/40.dc9ee196.js"><link rel="prefetch" href="/assets/js/41.1cb88b8b.js"><link rel="prefetch" href="/assets/js/42.6d190ca1.js"><link rel="prefetch" href="/assets/js/43.150e216d.js"><link rel="prefetch" href="/assets/js/44.dcf8b5ab.js"><link rel="prefetch" href="/assets/js/45.0d17c000.js"><link rel="prefetch" href="/assets/js/46.9d6b3456.js"><link rel="prefetch" href="/assets/js/47.935bb55f.js"><link rel="prefetch" href="/assets/js/48.e37390a0.js"><link rel="prefetch" href="/assets/js/49.39ecdc1f.js"><link rel="prefetch" href="/assets/js/5.b4dcdfe8.js"><link rel="prefetch" href="/assets/js/50.34f642ee.js"><link rel="prefetch" href="/assets/js/51.7c04e065.js"><link rel="prefetch" href="/assets/js/52.c2e77968.js"><link rel="prefetch" href="/assets/js/53.e8f488bb.js"><link rel="prefetch" href="/assets/js/54.8472234b.js"><link rel="prefetch" href="/assets/js/55.9fda41fb.js"><link rel="prefetch" href="/assets/js/56.5ae116f5.js"><link rel="prefetch" href="/assets/js/57.e90083d4.js"><link rel="prefetch" href="/assets/js/58.e7523e0f.js"><link rel="prefetch" href="/assets/js/59.2fca9c53.js"><link rel="prefetch" href="/assets/js/6.955c5a20.js"><link rel="prefetch" href="/assets/js/60.ff9fdb3f.js"><link rel="prefetch" href="/assets/js/61.7dc0adf4.js"><link rel="prefetch" href="/assets/js/62.c7045724.js"><link rel="prefetch" href="/assets/js/63.cbd39d0d.js"><link rel="prefetch" href="/assets/js/64.4d601c1a.js"><link rel="prefetch" href="/assets/js/65.15218456.js"><link rel="prefetch" href="/assets/js/66.7e1f444b.js"><link rel="prefetch" href="/assets/js/67.a60dd3b4.js"><link rel="prefetch" href="/assets/js/68.df242c65.js"><link rel="prefetch" href="/assets/js/69.0aba106a.js"><link rel="prefetch" href="/assets/js/7.2df1ad8e.js"><link rel="prefetch" href="/assets/js/70.032b2ea2.js"><link rel="prefetch" href="/assets/js/71.fa515120.js"><link rel="prefetch" href="/assets/js/72.7b317086.js"><link rel="prefetch" href="/assets/js/73.13ec7cf1.js"><link rel="prefetch" href="/assets/js/74.5c31c3bc.js"><link rel="prefetch" href="/assets/js/75.3fffb109.js"><link rel="prefetch" href="/assets/js/76.481b8f92.js"><link rel="prefetch" href="/assets/js/77.2e5a9e43.js"><link rel="prefetch" href="/assets/js/78.50ca3b2d.js"><link rel="prefetch" href="/assets/js/79.095abb54.js"><link rel="prefetch" href="/assets/js/8.b9729926.js"><link rel="prefetch" href="/assets/js/80.ce6927ce.js"><link rel="prefetch" href="/assets/js/81.a9e244ab.js"><link rel="prefetch" href="/assets/js/82.717a6857.js"><link rel="prefetch" href="/assets/js/83.c0096e25.js"><link rel="prefetch" href="/assets/js/84.e75abe60.js"><link rel="prefetch" href="/assets/js/85.83a789dd.js"><link rel="prefetch" href="/assets/js/86.f29e7031.js"><link rel="prefetch" href="/assets/js/87.24b43eac.js"><link rel="prefetch" href="/assets/js/88.25d37ad3.js"><link rel="prefetch" href="/assets/js/89.bacb17a9.js"><link rel="prefetch" href="/assets/js/9.b8842a49.js"><link rel="prefetch" href="/assets/js/90.4c8ba53b.js"><link rel="prefetch" href="/assets/js/91.ae3b3536.js"><link rel="prefetch" href="/assets/js/92.830fc4ef.js"><link rel="prefetch" href="/assets/js/93.eb63f786.js"><link rel="prefetch" href="/assets/js/94.089e533b.js"><link rel="prefetch" href="/assets/js/95.1866e61e.js"><link rel="prefetch" href="/assets/js/96.2b252fd5.js"><link rel="prefetch" href="/assets/js/97.e682a21e.js"><link rel="prefetch" href="/assets/js/98.cc2657f7.js"><link rel="prefetch" href="/assets/js/99.543f5ec0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d930c39a.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/whale.ico" alt="luyn12's blog" class="logo"> <span class="site-name can-hide">luyn12's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术文章" class="dropdown-title"><a href="/technology/" class="link-title">技术文章</a> <span class="title" style="display:none;">技术文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/technology/ui/" class="nav-link">前端技术栈</a></li><li class="dropdown-item"><!----> <a href="/technology/java/" class="nav-link">后端技术栈</a></li><li class="dropdown-item"><!----> <a href="/technology/database/" class="nav-link">数据库技术栈</a></li><li class="dropdown-item"><!----> <a href="/technology/mq/" class="nav-link">消息队列</a></li><li class="dropdown-item"><!----> <a href="/technology/schedule/" class="nav-link">任务调度</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程和指南" class="dropdown-title"><a href="/guides/" class="link-title">教程和指南</a> <span class="title" style="display:none;">教程和指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/guides/jdk/" class="nav-link">JDK安装和使用</a></li><li class="dropdown-item"><!----> <a href="/guides/database/" class="nav-link">数据库安装和使用</a></li><li class="dropdown-item"><!----> <a href="/guides/nodejs/" class="nav-link">NodeJs安装和使用</a></li><li class="dropdown-item"><!----> <a href="/guides/git/" class="nav-link">Git安装和使用</a></li><li class="dropdown-item"><!----> <a href="/guides/markdown/" class="nav-link">MarkDown安装和使用</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具和资源推荐" class="dropdown-title"><a href="/tools/" class="link-title">工具和资源推荐</a> <span class="title" style="display:none;">工具和资源推荐</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tools/development/idea/" class="nav-link">开发工具</a></li><li class="dropdown-item"><!----> <a href="/tools/plugins/snipaste/" class="nav-link">插件以及工具</a></li><li class="dropdown-item"><!----> <a href="/tools/lean/" class="nav-link">学习技巧</a></li><li class="dropdown-item"><!----> <a href="/tools/treasureWebsite/" class="nav-link">宝藏网站</a></li><li class="dropdown-item"><!----> <a href="/tools/github/" class="nav-link">Github技巧</a></li><li class="dropdown-item"><!----> <a href="/tools/initBlog/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试相关" class="dropdown-title"><a href="/interview/" class="link-title router-link-active">面试相关</a> <span class="title" style="display:none;">面试相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/life/" class="nav-link">非技术问题</a></li><li class="dropdown-item"><!----> <a href="/interview/ui/" class="nav-link">前端八股文</a></li><li class="dropdown-item"><!----> <a href="/interview/java/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Java面试题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="经验分享" class="dropdown-title"><a href="/experience/" class="link-title">经验分享</a> <span class="title" style="display:none;">经验分享</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/experience/bugs/" class="nav-link">开发BUG</a></li><li class="dropdown-item"><!----> <a href="/experience/practical/" class="nav-link">项目经验</a></li></ul></div></div> <a href="https://github.com/luyn12" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="./img/whale.png"> <div class="blogger-info"><h3>luyn12</h3> <span>😍</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术文章" class="dropdown-title"><a href="/technology/" class="link-title">技术文章</a> <span class="title" style="display:none;">技术文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/technology/ui/" class="nav-link">前端技术栈</a></li><li class="dropdown-item"><!----> <a href="/technology/java/" class="nav-link">后端技术栈</a></li><li class="dropdown-item"><!----> <a href="/technology/database/" class="nav-link">数据库技术栈</a></li><li class="dropdown-item"><!----> <a href="/technology/mq/" class="nav-link">消息队列</a></li><li class="dropdown-item"><!----> <a href="/technology/schedule/" class="nav-link">任务调度</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="教程和指南" class="dropdown-title"><a href="/guides/" class="link-title">教程和指南</a> <span class="title" style="display:none;">教程和指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/guides/jdk/" class="nav-link">JDK安装和使用</a></li><li class="dropdown-item"><!----> <a href="/guides/database/" class="nav-link">数据库安装和使用</a></li><li class="dropdown-item"><!----> <a href="/guides/nodejs/" class="nav-link">NodeJs安装和使用</a></li><li class="dropdown-item"><!----> <a href="/guides/git/" class="nav-link">Git安装和使用</a></li><li class="dropdown-item"><!----> <a href="/guides/markdown/" class="nav-link">MarkDown安装和使用</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具和资源推荐" class="dropdown-title"><a href="/tools/" class="link-title">工具和资源推荐</a> <span class="title" style="display:none;">工具和资源推荐</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tools/development/idea/" class="nav-link">开发工具</a></li><li class="dropdown-item"><!----> <a href="/tools/plugins/snipaste/" class="nav-link">插件以及工具</a></li><li class="dropdown-item"><!----> <a href="/tools/lean/" class="nav-link">学习技巧</a></li><li class="dropdown-item"><!----> <a href="/tools/treasureWebsite/" class="nav-link">宝藏网站</a></li><li class="dropdown-item"><!----> <a href="/tools/github/" class="nav-link">Github技巧</a></li><li class="dropdown-item"><!----> <a href="/tools/initBlog/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试相关" class="dropdown-title"><a href="/interview/" class="link-title router-link-active">面试相关</a> <span class="title" style="display:none;">面试相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/life/" class="nav-link">非技术问题</a></li><li class="dropdown-item"><!----> <a href="/interview/ui/" class="nav-link">前端八股文</a></li><li class="dropdown-item"><!----> <a href="/interview/java/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Java面试题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="经验分享" class="dropdown-title"><a href="/experience/" class="link-title">经验分享</a> <span class="title" style="display:none;">经验分享</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/experience/bugs/" class="nav-link">开发BUG</a></li><li class="dropdown-item"><!----> <a href="/experience/practical/" class="nav-link">项目经验</a></li></ul></div></div> <a href="https://github.com/luyn12" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/interview/life/" class="sidebar-link">非技术问题</a></li><li><a href="/interview/ui/" class="sidebar-link">前端八股文</a></li><li><a href="/interview/java/" aria-current="page" class="active sidebar-link">Java面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-连接查询" class="sidebar-link">1.连接查询</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-聚合函数" class="sidebar-link">2.聚合函数</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-sql-关键字" class="sidebar-link">3.SQL 关键字</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_4-sql-select-语句完整的执行顺序" class="sidebar-link">4.SQL Select 语句完整的执行顺序</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_5-数据库三范式" class="sidebar-link">5.数据库三范式</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-存储引擎" class="sidebar-link">6.存储引擎</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_7-数据库事务" class="sidebar-link">7.数据库事务</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_8-索引" class="sidebar-link">8.索引</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_9-数据库锁-高薪常问" class="sidebar-link">9.数据库锁(高薪常问)</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_10-mysql-优化" class="sidebar-link">10.MySql 优化</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-1-谈一谈你对-mybatis-框架的理解" class="sidebar-link">1.1 谈一谈你对 Mybatis 框架的理解</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-2-在-mybatis-中-和-的区别是什么" class="sidebar-link">1.2 在 mybatis 中,${} 和 #{} 的区别是什么?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-3-mybatis-编程步骤是什么样的" class="sidebar-link">1.3 MyBatis 编程步骤是什么样的？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-4-在-mybatis-中-resulttype-和-resultmap-的区别是什么" class="sidebar-link">1.4 在 mybatis 中,resultType 和 ResultMap 的区别是什么?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-5-在-mybatis-中你知道的动态-sql-的标签有哪些-作用分别是什么" class="sidebar-link">1.5 在 Mybatis 中你知道的动态 SQL 的标签有哪些?作用分别是什么?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-6-谈一下你对-mybatis-缓存机制的理解" class="sidebar-link">1.6 谈一下你对 mybatis 缓存机制的理解?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-1-spring的两大核心是什么" class="sidebar-link">2.1 Spring的两大核心是什么?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-2-spring-的生命周期" class="sidebar-link">2.2 Spring 的生命周期?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-3-spring-支持-bean-的作用域有几种吗-每种作用域是什么样的" class="sidebar-link">2.3 Spring 支持 bean 的作用域有几种吗? 每种作用域是什么样的?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-4-beanfactory-和-applicationcontext-有什么区别" class="sidebar-link">2.4 BeanFactory 和 ApplicationContext 有什么区别</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-5-spring-框架中都用到了哪些设计模式" class="sidebar-link">2.5 Spring 框架中都用到了哪些设计模式?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-6-spring-事务的实现方式和实现原理" class="sidebar-link">2.6 Spring 事务的实现方式和实现原理</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-7-spring-的对象默认是单例的还是多例的-单例-bean-存不存在线程安全问题呢" class="sidebar-link">2.7 Spring 的对象默认是单例的还是多例的? 单例 bean 存不存在线程安全问题呢?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-8-resource-和-autowired-依赖注入的区别是什么-qualifier-使用场景是什么" class="sidebar-link">2.8 @Resource 和@Autowired 依赖注入的区别是什么? @Qualifier 使用场景是什么?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-9-spring-的事务传播行为" class="sidebar-link">2.9 Spring 的事务传播行为</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-10-spring-中的隔离级别" class="sidebar-link">2.10 Spring 中的隔离级别</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-1-谈一下你对-springmvc-框架的理解" class="sidebar-link">3.1 谈一下你对 SpringMVC 框架的理解</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-2-springmvc-主要组件" class="sidebar-link">3.2 SpringMVC 主要组件</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-3-谈一下-springmvc-的执行流程以及各个组件的作用" class="sidebar-link">3.3 谈一下 SpringMVC 的执行流程以及各个组件的作用</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-4-说一下-springmvc-支持的转发和重定向的写法" class="sidebar-link">3.4 说一下 SpringMVC 支持的转发和重定向的写法</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-5-springmvc-的常用注解" class="sidebar-link">3.5 SpringMVC 的常用注解</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-6-谈一下-springmvc-统一异常处理的思想和实现方式" class="sidebar-link">3.6 谈一下 SpringMVC 统一异常处理的思想和实现方式</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-7-在-springmvc-中-如果想通过转发将数据传递到前台-有几种写法" class="sidebar-link">3.7 在 SpringMVC 中, 如果想通过转发将数据传递到前台,有几种写法?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-9-在-springmvc-中文件上传的使用步骤是什么样的-前台三要素是什么" class="sidebar-link">3.9 在 SpringMVC 中文件上传的使用步骤是什么样的? 前台三要素是什么?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_3-10-springmvc-中如何解决-get-post-请求中文乱码问题" class="sidebar-link">3.10 SpringMVC 中如何解决 GET|POST 请求中文乱码问题？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_4-1-什么是-dubbo" class="sidebar-link">4.1 什么是 dubbo</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_4-2-dubbo-的实现原理" class="sidebar-link">4.2 Dubbo 的实现原理</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_4-3-节点角色说明" class="sidebar-link">4.3 节点角色说明</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_4-4-调用关系说明" class="sidebar-link">4.4 调用关系说明</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_4-5-在实际开发的场景中应该如何选择-rpc-框架" class="sidebar-link">4.5 在实际开发的场景中应该如何选择 RPC 框架</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_5-1-zookeeper-是什么" class="sidebar-link">5.1 Zookeeper 是什么</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_5-2-zookeeper-的数据模型" class="sidebar-link">5.2 Zookeeper 的数据模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/interview/java/#_5-2-1-节点结构" class="sidebar-link">5.2.1 节点结构</a></li><li class="sidebar-sub-header level3"><a href="/interview/java/#_5-2-2-节点类型" class="sidebar-link">5.2.2 节点类型</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_5-3-zookeeper-的-watch-监听机制" class="sidebar-link">5.3 Zookeeper 的 watch 监听机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/interview/java/#_5-3-1-监听器原理" class="sidebar-link">5.3.1 监听器原理</a></li><li class="sidebar-sub-header level3"><a href="/interview/java/#_5-3-2监听器实际应用" class="sidebar-link">5.3.2监听器实际应用</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_5-4-zookeeper-的应用场景" class="sidebar-link">5.4 Zookeeper 的应用场景</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/interview/java/#_5-4-1-统一命名服务" class="sidebar-link">5.4.1 统一命名服务</a></li><li class="sidebar-sub-header level3"><a href="/interview/java/#_5-4-2-统一配置管理" class="sidebar-link">5.4.2 统一配置管理</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-1-springboot-是什么" class="sidebar-link">6.1 SpringBoot 是什么</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-2-springboot-的优点" class="sidebar-link">6.2 SpringBoot 的优点</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-3-运行-springboot-项目的方式" class="sidebar-link">6.3 运行 SpringBoot 项目的方式</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-4-springboot-的启动器-starte" class="sidebar-link">6.4 SpringBoot 的启动器 starte</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/interview/java/#_1-什么是-starter" class="sidebar-link">(1)什么是 starter?</a></li><li class="sidebar-sub-header level3"><a href="/interview/java/#_2-starter-执行原理" class="sidebar-link">(2)starter 执行原理?</a></li><li class="sidebar-sub-header level3"><a href="/interview/java/#_3-springboot-中常用的启动器" class="sidebar-link">(3)SpringBoot 中常用的启动器</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-5-springboot-运行原理剖析" class="sidebar-link">6.5 SpringBoot 运行原理剖析</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-6-springboot-热部署" class="sidebar-link">6.6 SpringBoot 热部署</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-7-springboot-中的配置文件" class="sidebar-link">6.7 SpringBoot 中的配置文件</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-8-springboot-支持哪些日志框架" class="sidebar-link">6.8 SpringBoot 支持哪些日志框架</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_6-9-springboot-常用注解" class="sidebar-link">6.9 SpringBoot 常用注解</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_7-1-soa-和微服务的区别" class="sidebar-link">7.1 SOA 和微服务的区别?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_7-2-springcloud-是什么" class="sidebar-link">7.2 SpringCloud 是什么?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_7-3-springcloud-的优势" class="sidebar-link">7.3 SpringCloud 的优势?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_7-4-springcloud-有哪些核心组件" class="sidebar-link">7.4 SpringCloud 有哪些核心组件?</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_7-5-springboot-和-springcloud-的关系" class="sidebar-link">7.5 SpringBoot 和 SpringCloud 的关系</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_7-6-springcloud-和-dubbo-的区别" class="sidebar-link">7.6 SpringCloud 和 Dubbo 的区别</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_7-6-eureka-和-zookeeper-的区别" class="sidebar-link">7.6 Eureka 和 Zookeeper 的区别</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-1-redis-是什么" class="sidebar-link">1.1 Redis 是什么？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-2-redis-的存储结构有哪些" class="sidebar-link">1.2 Redis 的存储结构有哪些？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-3-redis-的优点" class="sidebar-link">1.3 Redis 的优点？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-4-为什么要用-redis" class="sidebar-link">1.4 为什么要用 Redis</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-5-redis-的持久化" class="sidebar-link">1.5 redis 的持久化</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-6-redis-的缺点" class="sidebar-link">1.6 Redis 的缺点</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-7-redis-集群" class="sidebar-link">1.7 Redis 集群</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_1-8-redis-的分布式锁" class="sidebar-link">1.8 Redis 的分布式锁</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-1-消息中间件的区别" class="sidebar-link">2.1 消息中间件的区别</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-2-为什么要使用-mq" class="sidebar-link">2.2 为什么要使用 MQ</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-3-rocketmq-由哪些角色组成-每个角色作用和特点是什么" class="sidebar-link">2.3 RocketMQ 由哪些角色组成，每个角色作用和特点是什么？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-4-rocketmq-消费模式有几种" class="sidebar-link">2.4 RocketMQ 消费模式有几种？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-5-rocketmq-如何做负载均衡" class="sidebar-link">2.5 RocketMQ 如何做负载均衡？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-6-消息重复消费如何解决" class="sidebar-link">2.6 消息重复消费如何解决？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-7-如何让-rocketmq-保证消息的顺序消费" class="sidebar-link">2.7 如何让 RocketMQ 保证消息的顺序消费</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-8-rocketmq-如何保证消息不丢失" class="sidebar-link">2.8 RocketMQ 如何保证消息不丢失</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-9-rocketmq-的消息堆积如何处理" class="sidebar-link">2.9 RocketMQ 的消息堆积如何处理</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-10-rocketmq-如何实现分布式事务" class="sidebar-link">2.10 RocketMQ 如何实现分布式事务？</a></li><li class="sidebar-sub-header level2"><a href="/interview/java/#_2-11-任何一台-broker-突然宕机了怎么办" class="sidebar-link">2.11 任何一台 Broker 突然宕机了怎么办？</a></li></ul></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/interview/#面试相关" data-v-06225672>面试相关</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/luyn12" target="_blank" title="作者" class="beLink" data-v-06225672>luyn12</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-08-17</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Java面试题<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="java基础"><a href="#java基础" class="header-anchor">#</a> Java基础</h1> <h1 id="面向对象的特征"><a href="#面向对象的特征" class="header-anchor">#</a> 面向对象的特征</h1> <p>1、封装：将一个事物的属性行为封装在一个对象内部
2、继承：子类集成父类,可以使用父类的非私有化的属性行为,可以重写父类提供的方法进行扩展
3、多态：父类的引用指向子类的对象</p> <h1 id="基本数据类型"><a href="#基本数据类型" class="header-anchor">#</a> 基本数据类型</h1> <div class="language-java line-numbers-mode"><pre class="language-java"><code>	<span class="token keyword">char</span> <span class="token keyword">byte</span>
    <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token keyword">long</span> 
    <span class="token keyword">double</span> <span class="token keyword">float</span>
    <span class="token keyword">boolean</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h1 id="jdk-jre-jvm"><a href="#jdk-jre-jvm" class="header-anchor">#</a> JDK JRE JVM</h1> <p>1、JDK：java development kit java开发工具包,包含了JRE以及基础类库
2、JRE：java runtime environment java运行环境,包含了JVM以及核心类库
3、JVM：java V M 虚拟机,是java实现跨平台的核心,下载jdk版本的时候分windows版本以及linux版本，windows版本的jvm可以将java代码编译成windows下可以运行的字节码文件, linux版本的jvm可以将java代码编译成linux下可以运行的字节码文件，从而实现了跨平台</p> <p>4、JVM内存划分
堆：用于存储对象,以及对象的成员变量和成员方法
栈：用于方法执行时进栈,每一个帧栈储存方法内部的局部变量,以及对象堆内存的地址,程序计数器的地址
本地方法栈：本地方法调用的参数,局部变量,状态,返回地址,临时变量,相关异常处理信息
方法区：类的字节码文件会加载到方法区中,类的完成结构,字段,方法,继承关系以及接口,静态变量,常量池,符号的引用,方法字节码
程序计数器：每个方法分配一个计数器地址,用于记录资源被抢后当前方法执行到哪行,重新分配资源后继续执行</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>	main 方法的执行流程<span class="token punctuation">,</span>以及对象的创建回收
    代码示例<span class="token operator">:</span>
<span class="token comment">//-------------------------------------------------------------------</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">OrOrder</span> orOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
        <span class="token class-name">OrOrder</span> orOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    <span class="token punctuation">}</span>
<span class="token comment">//1.加载方法=会进栈</span>
<span class="token comment">//2.每一个方法在栈中称为栈帧</span>
<span class="token comment">//3.每一个栈帧中包含了四块</span>
<span class="token comment">//4.局部变量表=方法内部的局部变量，int,String</span>
<span class="token comment">//5.操作数栈=加减乘除进行运算的栈，ps.1+2 1先进栈，+进栈，2进栈，遇到+，+弹栈，1弹栈，运行1+2后，3进栈</span>
<span class="token comment">//6.动态链接=指向堆内存中对象的地址</span>
<span class="token comment">//7.方法出口</span>
<span class="token comment">//8.栈与堆之间的关系=局部变量中有引用类型的变量ps.user。user对象是new在堆中的,因此栈中的引用类型的局部变量存储的是地址指向的堆内存中实际的对象</span>
<span class="token comment">//9.每生成一个栈帧，就会对应的分配一块程序计数器的空间，</span>
<span class="token comment">//10.用于存储当前入栈的方法执行到了哪条语句</span>
<span class="token comment">//11.比如 soust1 sout2</span>
<span class="token comment">//12.当执行到sout1时，cpu被抢走了，此时程序计数器记录了sout2的位置，再次分配到cpu资源的时候，会开始执行sout2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h1 id="堆内存结构"><a href="#堆内存结构" class="header-anchor">#</a> 堆内存结构</h1> <p>堆内存是一种用于动态分配对象的内存区域，它在Java和许多其他编程语言中被广泛使用。堆内存的结构包括以下几个重要部分：</p> <ol><li><p>新生代（Young Generation）：</p> <ul><li>Eden空间：新创建的对象首先分配在Eden空间。当Eden空间满时，将触发Minor GC（年轻代垃圾回收），它会回收无用的对象并将部分存活对象转移到存活区。</li> <li>存活区（Survivor Space）：存活区是两个大小相等的区域（通常称为From和To）。在Minor GC期间，存活的对象从Eden空间和上一次垃圾回收后的存活区中复制到另一个存活区。</li></ul></li> <li><p>老年代（Old Generation）：</p> <ul><li>老年代用于存放长时间存活的对象。当对象在新生代经历多次垃圾回收后仍然存活，它们会被晋升到老年代。老年代的空间通常比新生代大。</li> <li>当老年代空间不足时，会触发Major GC（Full GC，即全局垃圾回收）。Major GC会对整个堆进行垃圾回收，包括新生代和老年代。</li></ul></li> <li><p>持久代（Permanent Generation）：</p> <ul><li>持久代（Java 8之前）或元空间（Java 8之后）存放的是类的元数据，例如类名、方法信息等。它在运行时被加载。</li> <li>元空间在Java 8之后取代了持久代，它的大小不再受限于固定的内存大小，而是根据需要动态分配。</li></ul></li></ol> <p>需要注意的是，堆内存是被所有线程共享的，用于存放对象实例。堆内存的大小可以通过Java虚拟机的启动参数进行设置，例如&quot;-Xmx&quot;参数用于设置堆的最大大小，&quot;-Xms&quot;参数用于设置堆的初始大小。</p> <p>通过合理地设置堆内存的大小和垃圾回收算法，可以提高应用程序的性能和内存利用率。</p> <h1 id="gc垃圾回收机制"><a href="#gc垃圾回收机制" class="header-anchor">#</a> GC垃圾回收机制</h1> <p>垃圾回收（Garbage Collection）是一种自动管理内存的机制，在Java和其他一些编程语言中广泛使用。它负责自动识别和清除不再被程序使用的对象，以释放其占用的内存空间。以下是GC垃圾回收机制的主要步骤和算法：</p> <ol><li><p>标记（Marking）：垃圾回收器从根对象（例如全局变量、活动线程的栈等）开始，通过可达性分析算法标记所有活动对象。所有未被标记的对象都可以被视为垃圾。</p></li> <li><p>清除（Sweeping）：清除阶段负责回收被标记为垃圾的对象所占用的内存空间。在清除过程中，垃圾回收器会释放被标记为垃圾的对象，并将其内存重新标记为空闲。</p></li> <li><p>压缩（Compacting）：在某些垃圾回收算法中，压缩阶段用于进一步优化内存空间。在压缩过程中，垃圾回收器会将存活的对象紧凑地移动到内存的一端，以便为新对象的分配提供连续的内存空间。</p></li></ol> <p>除了以上基本步骤，GC垃圾回收机制还有多种算法，用于选择要执行垃圾回收的时间点和方式。常见的GC算法包括：</p> <ol><li><p>标记-清除（Mark-Sweep）算法：基本的垃圾回收算法，通过标记和清除非活动对象来回收内存。</p></li> <li><p>标记-复制（Mark-Copy）算法：将内存分为两个区域（通常是新生代的Eden和存活区），根据对象的存活状态将对象从一个区域复制到另一个区域。</p></li> <li><p>标记-整理（Mark-Compact）算法：将存活的对象向内存的一端进行移动，然后清理边界外的内存空间。</p></li> <li><p>分代（Generational）算法：根据对象的生命周期将堆内存划分为不同的代（通常是年轻代和老年代），并使用不同的垃圾回收方法。</p></li></ol> <p>选择适合应用程序需求的垃圾回收算法可以在实现自动内存管理的同时提高性能和效率。Java虚拟机提供了不同的垃圾回收器和参数选项，开发人员可以根据应用程序的特点和要求进行适配和调优。</p> <h1 id="string-stringbuffer-stringbuilder"><a href="#string-stringbuffer-stringbuilder" class="header-anchor">#</a> String StringBuffer StringBuilder</h1> <p>String 字符串常量,类被final修饰,表示它不能被继承,即不能有子类。这样可以防止其他类对该类的扩展和修改。
通过将字符数组标记为 private final，String 类保证了字符串的不可变性。因为 final 修饰的变量不能被修改，所以字符串在创建后其内容不能被更改。
StringBuffer 与 StringBuilder 都继承自 AbstractStringBuilder StringBuffer 中的方法都加了同步锁,StringBuilder 中没加同步锁,因此 StringBuffer 是线程安全的,StringBuilder 线程不安全,总结如下:
（1）如果要操作少量的数据用 String；
（2）多线程操作字符串缓冲区下操作大量数据用 StringBuffer；
（3）单线程操作字符串缓冲区下操作大量数据用 StringBuilder。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    源码示例<span class="token operator">:</span>
<span class="token comment">//-------------------------------------------------------------------</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//-------------------------------------------------------------------</span>
 <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">StringBuffer</span>
    <span class="token keyword">extends</span> <span class="token class-name">AbstractStringBuilder</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token comment">//-------------------------------------------------------------------</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">StringBuilder</span>
    <span class="token keyword">extends</span> <span class="token class-name">AbstractStringBuilder</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">StringBuilder</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">StringBuilder</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h1 id="重载-重写"><a href="#重载-重写" class="header-anchor">#</a> 重载 重写</h1> <p>重载:
同一个类中,两个方法的方法名相同,参数不同,与返回值内有关系, 重载范例:StringBuilder中append方法
重写:
字类继承父类,将父类的非私有方法进行重新,对方法进行扩展增强,使方法符合自己的业务逻辑,重写范例:String 中的 equals 方法,重写了Object的equals方法,实现了内容的比较</p> <h1 id="equals"><a href="#equals" class="header-anchor">#</a> == equals</h1> <p>== 比较的是地址，基本数据类型比较的内容,引用数据类型比较的是地址
equals Object 类中的equals方法,用的就是==比较的是内容,String 类中,重写了equals方法,对每个字符串的字符进行比较,比较的是内容</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>	源码示例<span class="token operator">:</span>
<span class="token comment">//-------------------------------------------------------------------</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//-------------------------------------------------------------------</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> anotherString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    i<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h1 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h1> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">744</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">93</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">8220</span><span class="token punctuation">,</span> <span class="token number">4125</span><span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 交换相邻两个元素</span>
                    <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> str <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h1 id="string中常用的方法"><a href="#string中常用的方法" class="header-anchor">#</a> String中常用的方法</h1> <div class="language- line-numbers-mode"><pre class="language-text"><code>1. length()：返回字符串的长度。

2. charAt(int index)：返回指定位置(index)的字符。

3. concat(String str)：将指定的字符串(str)连接到原字符串的末尾，返回一个新字符串。

4. equals(Object obj)：比较字符串和指定对象(obj)是否相等。

5. indexOf(String str)：返回指定字符串(str)在原字符串中第一次出现的索引位置。

6. isEmpty()：判断字符串是否为空（长度为0）。

7. replace(char oldChar, char newChar)：将字符串中的所有旧字符(oldChar)替换为新字符(newChar)。

8. split(String regex)：将字符串根据指定的正则表达式(regex)分割为多个子字符串，返回一个字符串数组。

9. substring(int beginIndex)：返回从指定索引(beginIndex)开始到字符串末尾的子字符串。

10. toLowerCase()：将字符串中的所有字符转换为小写形式。

11. toUpperCase()：将字符串中的所有字符转换为大写形式。

12. trim()：去除字符串两端的空格。

13. startsWith(String prefix)：判断字符串是否以指定的前缀(prefix)开始。

14. endsWith(String suffix)：判断字符串是否以指定的后缀(suffix)结尾。

15. contains(CharSequence sequence)：判断字符串是否包含指定的字符序列。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h1 id="接口-抽象类"><a href="#接口-抽象类" class="header-anchor">#</a> 接口 抽象类</h1> <p>定义方式=接口（Interface）只能定义抽象的方法和常量，不包含具体的方法实现；而抽象类（Abstract Class）可以定义抽象方法和具体方法，还可以包含属性和构造方法。</p> <p>多继承=类只能单继承，但可以实现多个接口。一个类可以同时实现多个接口，从而获得多个接口的特性。而抽象类只能单继承，并且可以继承其他类或抽象类。</p> <p>实例化=接口不能被实例化，只能被实现；而抽象类不能被实例化，只能被继承，并通过子类实例化。</p> <p>方法实现=接口中的方法都是抽象的，没有方法体。实现接口的类必须实现接口中定义的所有方法。而抽象类中可以包含抽象方法和具体方法，子类可以选择性地重写抽象方法。</p> <p>对象关系=接口表示一种能力或行为，并且可以被多个类实现，通过接口可以实现多态性。抽象类是一种特殊类，用于被继承，并提供了部分实现的方法和属性。</p> <p>使用场景=：接口适用于定义一组相关的方法，可以被多个类实现。抽象类适用于作为继承体系的父类，提供一些公共的方法和属性，并定义一些抽象方法让子类实现。</p> <p>灵活性=接口提供了较高的灵活性，允许多个类实现同一个接口从而实现不同的行为。抽象类相对较少灵活，因为一个类只能继承一个抽象类。</p> <h1 id="jdk1-8新特性"><a href="#jdk1-8新特性" class="header-anchor">#</a> JDK1.8新特性</h1> <ol><li><p>Lambda表达式=Lambda表达式是Java 8中最显著的特性之一。它提供了一种简洁而便利的方式来编写函数式代码，并且可以使用函数式接口进行传递。</p></li> <li><p>函数式接口=Java 8引入了函数式接口的概念，即只包含一个抽象方法的接口。函数式接口的出现使得Lambda表达式可以作为函数式接口的实例进行使用。</p></li> <li><p>方法引用=方法引用是一种更简洁的Lambda表达式的写法，允许直接引用已经存在的方法。可以通过方法的名称来替代表达式，提供了更高的代码可读性。</p></li> <li><p>默认方法（Default Method）=接口中可以定义具体的默认方法，允许在不破坏现有实现类的情况下向接口添加新的方法。</p></li> <li><p>Stream API=Stream API提供了一种新的数据处理方式，可以以声明性的方式操作集合（Collection）和数组（Array）。通过使用Stream API，可以进行过滤、映射、排序、聚合等操作。</p></li> <li><p>Optional类=Optional是一个容器对象，可以包含或不包含某个值。使用Optional可以有效地避免空指针异常，并提供了一些有用的方法来处理可能为空的值。</p></li> <li><p>Date/Time API=JDK 1.8引入了全新的日期和时间API，包括LocalDate、LocalTime、LocalDateTime等类，提供了更方便、更安全的日期和时间操作方法。</p></li> <li><p>CompletableFuture类=CompletableFuture是一个可组合的异步编程工具，提供了更便捷的创建、组合和管理异步任务的方式。</p></li> <li><p>并行流（Parallel Stream）=JDK 1.8中的流API支持并行流，可以更方便地进行并行计算，提高程序的性能。</p></li></ol> <h1 id="异常"><a href="#异常" class="header-anchor">#</a> 异常</h1> <p>在Java中，异常（Exception）是指在程序运行过程中出现的意外情况或错误条件。异常用于标识程序运行时的错误，并提供一种机制来处理和捕获这些错误，以避免程序终止或出现不可预料的结果。</p> <p>Java中的异常分为两种类型：Checked Exception（受检异常）和Unchecked Exception（非受检异常）。</p> <ol><li><p>Checked Exception（受检异常）=受检异常是指在编译期间就需要处理的异常，即程序需要显式地声明处理这类异常，否则会编译错误。例如，IOException、SQLException等都属于受检异常。</p></li> <li><p>Unchecked Exception（非受检异常）=非受检异常是指在运行时才会出现的异常，一般由程序错误或其他问题引起。与受检异常不同，非受检异常可以不需要显式地捕获或声明处理。例如，NullPointerException、ArrayIndexOutOfBoundsException等都属于非受检异常。</p></li></ol> <p>常见的异常类还有以下几种：</p> <ul><li><p>RuntimeException=是所有非受检异常的根类。包括诸如NullPointerException、IllegalArgumentException和IndexOutOfBoundsException等。</p></li> <li><p>Exception=是所有异常的父类，它分为受检异常和非受检异常。直接继承Exception的子类通常是受检异常，而RuntimeException及其子类属于非受检异常。</p></li> <li><p>Throwable=是所有错误和异常的父类，它分为Error和Exception两个子类。Error指的是系统级的错误，通常无法处理，例如OutOfMemoryError、StackOverflowError等。</p></li></ul> <p>处理异常的方式有两种：</p> <ol><li><p>捕获异常（Catch Exception）=使用try-catch语句来捕获和处理指定类型的异常。在try代码块中编写可能抛出异常的代码，在catch代码块中捕获指定类型的异常，并提供处理逻辑。</p></li> <li><p>抛出异常（Throw Exception）=使用throw关键字抛出异常。当遇到异常情况时，使用throw关键字可以主动抛出指定的异常对象，并将其传递给上层调用栈。</p></li></ol> <h1 id="bio-nio-aio"><a href="#bio-nio-aio" class="header-anchor">#</a> BIO NIO AIO</h1> <p>BIO（同步阻塞IO）、NIO（同步非阻塞IO）和AIO（异步非阻塞IO）是在Java中用于进行输入输出操作的三种不同的编程模型。</p> <ol><li><p>BIO（同步阻塞IO）= BIO模型是最传统的IO模型，它以阻塞方式进行IO操作。在BIO模型中，当一个线程发起IO操作时，在IO操作完成之前，线程会被阻塞，无法执行其他任务。BIO适用于连接数较少的场景，且每个连接的数据交互量较小。</p></li> <li><p>NIO（同步非阻塞IO）= NIO模型使用了多路复用器（Selector）和缓冲区（Buffer），支持较高并发的IO操作。在NIO模型中，一个线程可以管理多个通道（Channel），通过轮询的方式，当某个通道有IO事件时才进行处理，避免了阻塞。NIO适用于连接数多且连接的数据交互量较大的场景。</p></li> <li><p>AIO（异步非阻塞IO）= AIO模型是Java 7引入的NIO 2.0的扩展，也被称为NIO.2。AIO模型使用异步方式进行IO操作，并且不需要轮询来等待IO事件。在AIO模型中，当一个操作完成时，会通过回调函数来通知应用程序。AIO适用于连接数多且每个连接的数据交互量较大的场景。</p></li></ol> <p>主要区别如下：</p> <ul><li>阻塞 vs 非阻塞：BIO是阻塞模式，NIO是非阻塞模式，AIO是异步非阻塞模式。</li> <li>并发能力：BIO是一对一的模型，每个连接都需要一个独立线程进行处理，连接数受限；NIO使用单个线程管理多个通道，连接数较大时可以更高效地利用系统资源；AIO使用异步回调方式，连接数不会导致线程数过多。</li> <li>IO操作方式：BIO是数据流式处理，NIO通过缓冲区（Buffer）来交换数据，AIO通过异步回调方式来处理IO事件。</li> <li>编程复杂度：BIO编程模型简单直观，但并发处理能力有限；NIO编程模型相对复杂，需要处理事件循环和缓冲区；AIO编程模型相对简单，利用异步回调方式实现。</li></ul> <p>选择何种模型取决于具体需求和场景。对于连接数较少且每个连接的数据交互量较小的情况，BIO是合适的选择；对于连接数多且交互量较大的情况，NIO和AIO更适合。</p> <h1 id="synchronized"><a href="#synchronized" class="header-anchor">#</a> synchronized</h1> <p>synchronized 同步锁的原理，
在Java中，synchronized关键字是用于实现线程同步的机制之一，它能够确保同一时间只有一个线程可以访问某个对象或代码块。synchronized的原理可以归纳如下：</p> <ol><li><p>内部锁（Monitor Lock）= 当一个线程进入了一个带有synchronized关键字的代码块或方法时，该线程会获取到与该对象关联的内部锁（Monitor Lock），其他线程需要等待锁的释放才能进入该代码块。</p></li> <li><p>互斥性（Mutual Exclusion）= synchronized保证同一时间只有一个线程可以持有某个对象的锁，其他线程在获取锁之前需要等待，从而实现了互斥性，避免了多个线程同时访问共享资源导致的数据竞争。</p></li> <li><p>可重入性（Reentrancy）= synchronized是可重入的，即在同一个线程中，可以重复获取已经持有的锁，避免死锁的发生。当线程再次进入同步代码块时，会增加锁的计数器，只有当计数器清零时才释放锁。</p></li> <li><p>保证可见性（Visibility）= synchronized不仅保证了互斥性，还保证了对共享变量的修改对其他线程的可见性。当一个线程释放锁时，会将对共享变量的最新值刷新到主内存，并在获取锁的时候从主内存中重新加载最新值，确保了可见性。</p></li></ol> <p>需要注意的是，synchronized的作用范围可以是方法、代码块或静态方法，也可以通过synchronized(this)、synchronized(object)等方式来指定锁的对象。另外，synchronized还可以使用在类的静态成员上，表示对类级别的锁定。</p> <p>总的来说，synchronized关键字通过内部锁机制实现了对共享资源的线程安全访问，保证了互斥性、可重入性和可见性。然而，在并发场景下，过度使用synchronized可能会导致性能下降，因此在遇到性能问题时，可以考虑使用更高级别的同步机制，如Lock接口和Condition接口。</p> <h1 id="synchronized-volatile"><a href="#synchronized-volatile" class="header-anchor">#</a> synchronized volatile</h1> <p>synchronized和volatile都是Java中用于实现线程安全的机制，但它们的作用和应用场景有所不同，以下是它们的区别：</p> <ol><li><p>作用范围=synchronized关键字可以用于代码块、方法以及实例方法等，用于实现临界区的同步。而volatile关键字只能修饰变量，用于保证变量的可见性和禁止指令重排序。</p></li> <li><p>并发控制=synchronized通过获取和释放锁的方式，实现了互斥性和可见性，能够确保同一时间只有一个线程可以进入synchronized的代码块或方法中。而volatile关键字主要用于保证线程对被修饰变量的读写操作具有可见性，即当一个线程修改了volatile变量的值时，其他线程能够立即看到最新的值。</p></li> <li><p>原子性=synchronized关键字能够保证临界区内的代码是原子操作，即一个线程执行临界区代码时，其他线程无法并发访问。而volatile关键字不能直接实现原子性，它只能保证可见性，对于复合操作，如i++这种非原子操作，多个线程同时对volatile变量进行操作可能会导致并发问题。</p></li> <li><p>性能开销=synchronized在获取和释放锁的过程中会引入一定的性能开销，会涉及线程的上下文切换和锁的竞争。而volatile关键字的性能开销相对较低，因为它不涉及锁的获取和释放。但是，在高并发情况下，过度使用volatile可能会导致CPU的缓存竞争，进而影响性能。</p></li></ol> <p>综上所述，synchronized关键字主要用于实现临界区的同步和互斥，保证线程安全性；而volatile关键字主要用于保证变量的可见性，禁止指令重排序。在选择使用哪种机制时，需要根据具体的需求和线程安全的要求来进行选择。</p> <h1 id="synchronized-lock"><a href="#synchronized-lock" class="header-anchor">#</a> synchronized lock</h1> <p>synchronized和Lock（锁）是Java中常用的两种线程同步机制，它们有以下区别：</p> <ol><li><p>使用方式=synchronized是Java语言提供的关键字，在使用时不需要显式地创建锁对象。而Lock是Java.util.concurrent包提供的接口，需要通过显式地创建锁对象来使用。</p></li> <li><p>灵活性=synchronized是一种隐式的锁机制，它负责锁的获取和释放，并且具有可重入性、互斥性和可见性。相比之下，Lock接口提供了更灵活、更强大的锁定操作，如可定时的锁、可轮询的锁、可中断的锁等，同时可以支持公平锁和非公平锁。</p></li> <li><p>锁的获取与释放=synchronized的获取和释放锁的过程是由Java虚拟机自动管理的，当线程执行完synchronized代码块或方法时，会自动释放锁。而Lock接口需要显式地调用lock()方法获取锁，并在合适的时机手动调用unlock()方法来释放锁，这需要开发者自己管理锁的获取和释放的过程。</p></li> <li><p>扩展性=相比synchronized，Lock接口提供了更好的扩展性。它可以配合Condition接口实现更复杂的线程调度和等待/通知机制，比如支持多个条件变量、有序的等待通知等。</p></li> <li><p>性能=在低竞争情况下，synchronized的性能通常是比较高的，并且它不需要显式地创建和释放锁对象，编写起来也更加简单。而Lock接口相对于synchronized来说，在高并发情况下具有更好的性能表现，但同时也需要更多的注意和保证。</p></li></ol> <p>综合来说，synchronized是在Java语言级别上提供的简单、方便的线程同步机制，适用于大部分的同步需求；而Lock接口提供了更灵活、更强大的线程同步功能，并且在特定情况下可以提供更好的性能和可扩展性。在实际使用中，需要根据具体的场景和需求来选择合适的同步机制。</p> <h1 id="threadlocal-原理"><a href="#threadlocal-原理" class="header-anchor">#</a> Threadlocal 原理</h1> <p>ThreadLocal= 为共享变量在每个线程中创建一个副本，每个线程都可以访问自己内部的副本变量。通过 threadlocal 保证线程的安全性。
其实在 ThreadLocal 类中有一个静态内部类 ThreadLocalMap(其类似于 Map)，
用键值对的形式存储每一个线程的变量副本，ThreadLocalMap 中元素的 key 为当前
ThreadLocal 对象，而 value 对应线程的变量副本。
ThreadLocal 本身并不存储值，它只是作为一个 key 保存到 ThreadLocalMap
中，但是这里要注意的是它作为一个 key 用的是弱引用，因为没有强引用链，弱引用在 GC
的时候可能会被回收。这样就会在 ThreadLocalMap 中存在一些 key 为 null 的键值对
（Entry）。因为 key 变成 null 了，我们是没法访问这些 Entry 的，但是这些 Entry 本身是
不会被清除的。如果没有手动删除对应 key 就会导致这块内存即不会回收也无法访问，也
就是内存泄漏。
使用完 ThreadLocal 之后，记得调用 remove 方法。 在不使用线程池的前提下，
即使不调用 remove 方法，线程的&quot;变量副本&quot;也会被 gc 回收，即不会造成内存泄漏的情况</p> <h1 id="同步锁-死锁-乐观锁-悲观锁"><a href="#同步锁-死锁-乐观锁-悲观锁" class="header-anchor">#</a> 同步锁 死锁 乐观锁 悲观锁</h1> <p>同步锁（Synchronized Lock）=是一种用于实现多线程同步的机制，可以保证同一时间只有一个线程可以访问共享资源。通过加锁和释放锁的机制，同步锁能够避免多线程访问时可能导致的数据竞争和不一致性问题。</p> <p>死锁（Deadlock）=指的是两个或多个线程互相持有对方所需的资源，造成彼此都无法继续执行的状态。通常死锁发生的条件有四个：互斥条件、请求与保持条件、不剥夺条件和循环等待条件。解决死锁问题的常见方法包括破坏死锁产生的条件、死锁检测与恢复、死锁避免等。</p> <p>乐观锁（Optimistic Lock）=是一种乐观的并发控制策略，它假设并发冲突不经常发生。在乐观锁中，多个线程可以同时读取同一数据，但在进行数据更新时，会检查是否有其他线程对数据进行了修改。如果没有发生冲突，则成功进行更新操作；如果发生冲突，则需要进行回滚或重试。</p> <p>悲观锁（Pessimistic Lock）=是一种悲观的并发控制策略，它假设并发冲突经常发生。在悲观锁中，对共享资源的访问被限制为一次只能有一个线程进行，其他线程需要等待。悲观锁通常使用互斥锁（如synchronized）来实现，保证在同一时间只有一个线程能够访问共享资源。</p> <p>乐观锁和悲观锁的选择取决于并发冲突的频率和程度。如果并发冲突较少且冲突的概率低，使用乐观锁可以提高并发性能；如果并发冲突较多或冲突的概率较高，使用悲观锁可以确保数据的一致性和安全。在实际应用中，乐观锁常用于读多写少的场景，而悲观锁常用于写多读少或写写冲突较多的场景。</p> <h1 id="线程-进程"><a href="#线程-进程" class="header-anchor">#</a> 线程 进程</h1> <p>线程=是进程的一个实体，是 cpu 调度和分派的基本单位，是比进程更小的可以独立运行的基本单位。
进程=具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位。
特点=线程的划分尺度小于进程，这使多线程程序拥有高并发性，进程在运行时各自内存单元相互独立，线程之间 内存共享，这使多线程编程可以拥有更好的性能和用户体验。</p> <h1 id="创建线程"><a href="#创建线程" class="header-anchor">#</a> 创建线程</h1> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1.</span> 继承<span class="token class-name">Thread</span>类：创建一个继承自<span class="token class-name">Thread</span>类的子类，并重写其<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法来定义线程的执行逻辑。然后，通过创建线程对象并调用<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法来启动线程。
   <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 线程的执行逻辑</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 创建并启动线程</span>
   <span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token number">2.</span> 实现<span class="token class-name">Runnable</span>接口：创建一个实现了<span class="token class-name">Runnable</span>接口的类，并实现其<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法。然后，通过创建<span class="token class-name">Thread</span>对象并将<span class="token class-name">Runnable</span>对象作为参数传递给<span class="token class-name">Thread</span>的构造函数来启动线程。

   <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 线程的执行逻辑</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 创建并启动线程</span>
   <span class="token class-name">MyRunnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
   thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token number">3.</span> 使用匿名类或<span class="token class-name">Lambda</span>表达式：可以使用匿名类或<span class="token class-name">Lambda</span>表达式快速创建线程，省略了显式定义一个<span class="token class-name">Thread</span>或实现一个<span class="token class-name">Runnable</span>接口的步骤。

   使用匿名类：

   <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 线程的执行逻辑</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token comment">// 启动线程</span>
   thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   使用<span class="token class-name">Lambda</span>表达式：

   <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
       <span class="token comment">// 线程的执行逻辑</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

   <span class="token comment">// 创建并启动线程</span>
   <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
   thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">4.</span> 实现 <span class="token class-name">Callable</span> 接口并重写 call 方法，创建线程。可以获取线程执行结果的返回
值，并且可以抛出异常。

这些是<span class="token class-name">Java</span>中创建线程的几种常用方式。每种方式都有适用的场景和特点，你可以根据具体需求选择合适的方式来创建线程。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><h1 id="runnable-callable"><a href="#runnable-callable" class="header-anchor">#</a> Runnable   Callable</h1> <p>Runnable和Callable是Java并发编程中用于创建线程的两个接口，它们有以下几个区别：</p> <ol><li><p>返回值 = Runnable接口的run()方法没有返回值，它的执行结果无法获取；而Callable接口的call()方法有返回值，可以返回执行结果。</p></li> <li><p>异常处理 = Runnable接口的run()方法不能抛出任何受检查异常，只能在方法体内捕获并处理异常；而Callable接口的call()方法可以抛出受检查异常，可以在方法签名中声明，也可以在方法体内捕获和处理。</p></li> <li><p>使用方式 = Runnable接口通常用于执行一段没有返回结果的任务，比如执行一些耗时的操作；而Callable接口通常用于执行一段有返回结果的任务，并且可以通过返回值进行操作和处理。</p></li> <li><p>线程池支持 = Java的Executor框架中的线程池可以直接提交实现了Runnable接口的任务，并执行其中的run()方法；但是对于实现了Callable接口的任务，需要通过ExecutorService的submit()方法来提交，并返回一个Future对象，通过该对象可以获取任务执行的返回结果。</p></li></ol> <p>总的来说，Runnable适用于不需要返回结果或不抛出异常的简单任务；而Callable适用于需要返回结果或可能抛出异常的复杂任务。在Java中，我们可以根据具体的需求选择使用Runnable或Callable接口来创建线程。</p> <h1 id="启动一个新线程、调用-start-和-run-方法的区别"><a href="#启动一个新线程、调用-start-和-run-方法的区别" class="header-anchor">#</a> 启动一个新线程、调用 start 和 run 方法的区别</h1> <div class="language-java line-numbers-mode"><pre class="language-java"><code>要启动一个新线程，可以使用<span class="token class-name">Thread</span>类的实例并调用它的<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法。以下是启动新线程的示例代码：

<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程的执行逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

在上述代码中，我们创建了一个<span class="token class-name">Thread</span>对象，并重写了其<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法来定义线程的执行逻辑。然后通过调用<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法来启动线程。<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法会启动一个新线程，并在新线程中执行<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法中的代码。

需要注意的是，不要直接调用<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法来启动线程，而是应该调用<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法。调用<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法只会在当前线程中以普通的方法调用方式执行<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法的代码，并不会启动一个新线程。以下是错误的示例：

<span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程的执行逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误！不要直接调用run()方法</span>

在上述错误示例中，调用<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法只会在当前线程中执行<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法的代码，不会启动一个新线程。

使用<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法启动线程可以让操作系统在合适的时候创建并调度线程，使得线程可以并发地执行。而直接调用<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法则相当于在当前线程中顺序执行<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法的代码，无法实现并发执行的效果。因此，在启动新线程时，应该使用<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法而不是<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h1 id="线程有哪几种状态以及各种状态之间的转换"><a href="#线程有哪几种状态以及各种状态之间的转换" class="header-anchor">#</a> 线程有哪几种状态以及各种状态之间的转换</h1> <p>在Java中，线程有以下几种状态：</p> <ol><li><p>新建（New）：线程对象被创建但还未启动。</p></li> <li><p>运行（Runnable）：线程正在执行或准备开始执行。</p></li> <li><p>阻塞（Blocked）：线程被阻塞并暂停执行，等待某个条件的满足。</p></li> <li><p>等待（Waiting）：线程进入一种无限期等待状态，直到其他线程进行特定的通知或中断。</p></li> <li><p>时间等待（Timed Waiting）：线程等待一段固定的时间，在等待时间结束后自动恢复。</p></li> <li><p>终止（Terminated）：线程执行完毕或被提前终止。</p></li></ol> <p>以下是不同状态之间的转换：</p> <ul><li><p>新建（New） -&gt; 运行（Runnable）：调用线程对象的start()方法。</p></li> <li><p>运行（Runnable） -&gt; 阻塞（Blocked）：线程等待获取某个锁。</p></li> <li><p>运行（Runnable） -&gt; 等待（Waiting）：线程调用Object的wait()方法，或者等候IO操作完成。</p></li> <li><p>运行（Runnable） -&gt; 时间等待（Timed Waiting）：线程调用Thread的sleep()方法，或者等待一段时间。</p></li> <li><p>阻塞（Blocked） -&gt; 运行（Runnable）：线程成功获取了等待的锁。</p></li> <li><p>阻塞（Blocked） -&gt; 终止（Terminated）：其他线程调用了阻塞线程的interrupt()方法，中断了线程。</p></li> <li><p>等待（Waiting） -&gt; 运行（Runnable）：其他线程调用了等待线程的notify()或notifyAll()方法，唤醒了线程。</p></li> <li><p>等待（Waiting） -&gt; 终止（Terminated）：其他线程调用了等待线程的interrupt()方法，中断了线程。</p></li> <li><p>时间等待（Timed Waiting） -&gt; 运行（Runnable）：时间等待结束，线程恢复执行。</p></li> <li><p>时间等待（Timed Waiting） -&gt; 终止（Terminated）：其他线程调用了时间等待线程的interrupt()方法，中断了线程。</p></li> <li><p>运行（Running） -&gt; 终止（Terminated）：线程执行完毕或者其他线程提前调用了线程的interrupt()方法。</p></li></ul> <p>这些是线程的不同状态以及状态之间的转换。线程状态的变化是由操作系统和JVM负责管理和控制的。</p> <h1 id="线程相关的基本方法"><a href="#线程相关的基本方法" class="header-anchor">#</a> 线程相关的基本方法</h1> <p>以下是Java中与线程相关的一些基本方法：</p> <ol><li><p>start()：启动线程。调用线程对象的start()方法会创建一个新的线程，并调用该线程的run()方法来执行线程的任务。</p></li> <li><p>run()：定义线程的执行逻辑。run()方法是线程的入口点，线程在启动后会执行run()方法中的代码逻辑。</p></li> <li><p>sleep()：使线程暂停执行一段时间。调用Thread类的sleep()方法可以让当前线程睡眠指定的毫秒数，暂停执行。在睡眠时间结束后，线程会被重新唤醒并继续执行。</p></li> <li><p>yield()：让出CPU执行权。调用Thread类的yield()方法可以让当前线程主动暂停执行，让出CPU执行权给其他线程。调度器会在合适的时机选择其他线程继续执行。</p></li> <li><p>join()：等待线程终止。调用Thread类的join()方法可以使当前线程等待被调用的线程执行完成。即当前线程会在join()方法调用处阻塞，直到被调用的线程执行完毕。</p></li> <li><p>interrupt()：中断线程。调用Thread类的interrupt()方法可以中断线程的执行。它会设置线程的中断状态，可以在被中断的线程中检查中断状态，并相应地做出处理。</p></li> <li><p>isInterrupted()：检查线程的中断状态。调用Thread类的isInterrupted()方法可以检查线程的中断状态，判断线程是否被中断。</p></li> <li><p>setPriority()：设置线程的优先级。调用Thread类的setPriority()方法可以设置线程的优先级。优先级较高的线程在竞争CPU资源时会获得更多的执行机会。</p></li></ol> <p>这些是一些常用的线程相关方法，可以帮助我们控制和管理线程的执行。根据具体需求，我们可以使用这些方法来实现所需的线程行为。</p> <h1 id="wait-sleep-区别"><a href="#wait-sleep-区别" class="header-anchor">#</a> wait()  sleep() 区别</h1> <p>wait()和sleep()是Java中用于线程操作的两个方法，它们有以下几个区别：</p> <ol><li><p>使用方式：wait()方法是Object类的方法，可以在任何对象上调用；而sleep()方法是Thread类的静态方法，只能在当前线程中调用。</p></li> <li><p>锁的释放：在调用wait()方法时，线程会释放它所持有的对象锁，进入等待状态；而调用sleep()方法时，线程会保持它所持有的对象锁，不会释放。</p></li> <li><p>应用场景：wait()方法通常用于线程间的协作，可以用来实现线程的等待和通知机制；而sleep()方法通常用于线程的暂停和延迟执行，可以用来控制线程的时间间隔或顺序。</p></li> <li><p>唤醒：调用wait()方法后，需要其他线程调用相应对象的notify()或notifyAll()方法来唤醒处于等待状态的线程；而调用sleep()方法后，线程会在指定的时间过后自动苏醒。</p></li> <li><p>异常抛出：调用wait()方法必须在synchronized块或方法内部，否则会抛出IllegalMonitorStateException；而调用sleep()方法不需要在同步块或方法内部。</p></li></ol> <p>总的来说，wait()方法主要用于线程间的等待和通知，需要配合synchronized块或方法使用；而sleep()方法主要用于线程的暂停和延迟执行，不需要在同步块或方法内部使用。使用wait()方法时，线程会释放对象锁，而使用sleep()方法时，线程会保持对象锁。在具体使用时，根据需要选择使用wait()还是sleep()方法。</p> <h1 id="线程池的分类"><a href="#线程池的分类" class="header-anchor">#</a> 线程池的分类</h1> <p>线程池是Java多线程编程中常用的一种机制，它通过预先创建一组线程来执行任务，从而提高了多线程环境下任务执行的效率。根据不同的需求和使用场景，线程池可以分为以下几种类型：</p> <ol><li><p>固定大小线程池（FixedThreadPool）：固定大小线程池在创建时会预先指定线程的数量，并且这些线程会一直存在直到线程池被显式关闭。适用于需要控制线程数量并且执行长期任务的情况。</p></li> <li><p>缓存线程池（CachedThreadPool）：缓存线程池会根据需要自动创建线程，并且会在线程闲置超过指定时间后销毁线程。适用于执行短期、异步性高的任务的情况。</p></li> <li><p>单线程池（SingleThreadExecutor）：单线程池中只有一个线程执行任务，如果该线程因异常而终止，会创建一个新的线程来替代。适用于需要保证任务按顺序执行的情况。</p></li> <li><p>定时任务线程池（ScheduledThreadPool）：定时任务线程池可用于定时执行任务或周期性执行任务。它可以预定执行任务的时间，保证任务按计划执行。</p></li> <li><p>工作窃取线程池（ForkJoinPool）：工作窃取线程池是Java 7中引入的，适用于需要进行并行计算的任务。它使用&quot;工作窃取&quot;的算法，可以充分利用多处理器的优势。</p></li></ol> <p>不同类型的线程池适用于不同的场景，选择合适的线程池类型可以提高任务执行的效率和资源利用率。在实际应用中，根据具体的业务需求和性能要求选择适合的线程池类型。</p> <h1 id="线程池核心参数"><a href="#线程池核心参数" class="header-anchor">#</a> 线程池核心参数</h1> <p>线程池是一种用于管理和调度线程的技术，并且它具有一些核心参数来控制其行为和性能。以下是线程池的一些核心参数：</p> <ol><li><p>核心线程数（core pool size）：线程池中最小的活动线程数。即使线程池中没有任务需要执行，核心线程也会保持活动状态。当有新任务提交时，线程池会创建新的线程来执行任务，直到达到核心线程数。</p></li> <li><p>最大线程数（maximum pool size）：线程池中允许存在的最大线程数。当线程池中的线程数达到最大线程数，并且任务队列已满时，新的任务将会触发线程池的拒绝策略。</p></li> <li><p>任务队列（work queue）：用于存储等待执行的任务的队列。线程池中的线程会从任务队列中获取任务并执行。任务队列可以是有界队列或无界队列。</p></li> <li><p>空闲线程存活时间（keep-alive time）：当线程池中的线程数大于核心线程数，并且处于空闲状态时，空闲线程存活时间定义了它们在被终止之前可以等待新任务的时间。</p></li> <li><p>拒绝策略（rejection policy）：当线程池无法接受新任务时的处理策略。常见的拒绝策略包括抛出异常、丢弃任务、丢弃队列中最早的任务等。</p></li></ol> <p>这些核心参数可以根据具体的应用场景和需求进行配置，以达到最佳的性能和资源利用。</p> <h1 id="线程池的原理"><a href="#线程池的原理" class="header-anchor">#</a> 线程池的原理</h1> <p>线程池是一种线程管理技术，它包含了一组线程，用于执行提交的任务。线程池的原理可以总结如下：</p> <ol><li><p>初始化线程池：在创建线程池时，会指定核心线程数、最大线程数、任务队列等参数。线程池会根据核心线程数创建最小数量的线程，并将它们标记为可用状态。</p></li> <li><p>提交任务：当一个新任务被提交到线程池时，线程池会根据以下规则进行处理：</p> <ul><li>如果当前活动线程数小于核心线程数，线程池会创建一个新线程来执行任务。</li> <li>如果当前活动线程数达到核心线程数，线程池会将任务添加到任务队列中。</li> <li>如果任务队列已满，并且当前活动线程数小于最大线程数，线程池会创建新的线程来执行任务。</li> <li>如果活动线程数达到最大线程数，并且任务队列已满，线程池会根据拒绝策略来处理新任务。</li></ul></li> <li><p>执行任务：线程池中的线程会从任务队列中获取任务进行执行。当线程完成任务后，它会返回线程池并等待下一个任务的分配。</p></li> <li><p>线程管理：线程池会根据需要动态地管理线程的数量。当线程池中的线程在一段时间内没有任务可执行时，超过空闲线程存活时间的线程会被终止，从而减少资源占用。</p></li></ol> <p>通过使用线程池，可以提供以下好处：</p> <ul><li>降低线程创建和销毁的开销，提高线程的重用性和性能。</li> <li>控制线程的数量，避免线程过多导致资源耗尽。</li> <li>提供任务队列来平衡任务的处理能力。</li> <li>根据需求动态伸缩线程池的大小，适应不同的负载情况。</li></ul> <p>线程池是并发编程中常用的一种技术，能够有效管理和调度线程，提高应用程序的性能和稳定性。</p> <h1 id="tcp-udp"><a href="#tcp-udp" class="header-anchor">#</a> TCP  UDP</h1> <p>TCP（传输控制协议）和UDP（用户数据报协议）是互联网协议套件中的两个常用传输层协议，用于在计算机之间进行数据传输。下面是TCP和UDP的区别：</p> <ol><li><p>连接性：TCP是面向连接的协议，它在通信之前需要建立一个连接，而UDP是无连接的协议，它直接发送数据报给目标地址。</p></li> <li><p>可靠性：TCP提供可靠的数据传输，它使用流控制、序列号和确认机制，确保数据的可靠性和顺序性。UDP不提供可靠性保证，它没有确认机制，数据报可能会丢失或乱序。</p></li> <li><p>应用场景：TCP适用于要求可靠数据传输的应用，如文件传输、电子邮件、网页访问等。UDP适用于实时性要求较高的应用，如音视频流媒体、在线游戏等，因为UDP具有较低的延迟和较少的数据处理开销。</p></li> <li><p>通信方式：TCP是面向字节流的通信方式，它将数据划分为数据流，保证数据的有序传输。UDP是面向数据报的通信方式，它将数据划分为数据报，每个数据报都是独立的，并且可能以不同的顺序到达。</p></li> <li><p>连接状态维护：TCP需要在端点之间维护连接状态信息，包括序列号、窗口大小、拥塞控制等。UDP不维护连接状态，每个数据报都是独立的，没有额外开销。</p></li> <li><p>传输效率：由于TCP提供了可靠性和顺序性保证，它的传输效率相对较低，并且对网络资源的占用较多。UDP没有这些保证和开销，因此传输效率相对较高。</p></li> <li><p>头部开销：TCP的头部开销较大，约为20字节，用于建立连接、传输控制和错误校验。UDP的头部开销较小，约为8字节，只包含数据报的源端口、目标端口和长度等基本信息。</p></li></ol> <p>综上所述，TCP和UDP在连接性、可靠性、应用场景、通信方式、开销等方面存在明显的差异，根据不同应用需求和网络条件的不同，选择合适的协议进行数据传输。</p> <h1 id="tcp-的三次握手"><a href="#tcp-的三次握手" class="header-anchor">#</a> TCP 的三次握手</h1> <p>TCP的三次握手是建立TCP连接的过程。以下是三次握手的具体步骤：</p> <ol><li><p>第一次握手(SYN)：
客户端向服务器发送一个SYN包（同步序列编号），其中包含自己的初始序列号（Seq=X）。
客户端进入SYN_SENT状态，等待服务器的响应。</p></li> <li><p>第二次握手(SYN + ACK)：
服务器收到客户端的SYN包后，会返回一个带有确认和自己的SYN包的ACK包（确认号为客户端的初始序列号+1，即Ack=X+1）。
服务器还会为自己初始化一个序列号（Seq=Y）。
服务器进入SYN_RCVD状态。</p></li> <li><p>第三次握手(ACK)：
客户端收到服务器的SYN + ACK包后，会向服务器发送一个确认包ACK（确认号为服务器的序列号+1，即Ack=Y+1）。
服务器收到客户端的ACK包后，会进入ESTABLISHED状态，而客户端也会进入ESTABLISHED状态。
至此，TCP连接建立成功。</p></li></ol> <p>三次握手的目的是确保客户端和服务器之间的通信路径是正常的，并且双方能够正确接收对方的数据。通过三次握手，双方可以确认彼此的初始序列号，并同步初始序列号，以便后续的数据传输。</p> <h1 id="http-重定向-请求转发-区别"><a href="#http-重定向-请求转发-区别" class="header-anchor">#</a> HTTP  重定向 请求转发 区别</h1> <p>重定向（Redirect）和请求转发（Forward）都是HTTP中用来处理请求的机制，但它们有一些关键的区别。</p> <p>重定向：</p> <ol><li>重定向是通过返回一个特定的状态码和Location头来告诉客户端将请求发送到另一个URL。</li> <li>当服务器收到请求后，它会返回一个状态码（通常是3xx系列的状态码），以及一个新的目标URL。</li> <li>客户端收到重定向响应后，会重新发送一个新的请求到所指示的目标URL。</li> <li>客户端和服务器之间进行多次请求-响应循环。</li> <li>重定向会导致额外的网络请求和延迟，因为客户端需要发送多个请求。</li></ol> <p>请求转发：</p> <ol><li>请求转发是在服务器内部完成的，客户端不知道请求从一个资源转发到另一个资源。</li> <li>当服务器收到请求后，它会在服务器内部将请求转发到另一个资源（例如另一个Servlet或JSP页面）。</li> <li>客户端并不知道实际处理请求的资源，只知道最初的URL。</li> <li>请求转发是服务器内部的操作，不需要向客户端发送额外的响应，因此效率较高。</li></ol> <p>所以，重定向是通过发送多个请求和响应来处理请求，并且会向客户端显示新的URL，而请求转发是在服务器内部进行的，客户端不会察觉到资源的变化。重定向适用于需要将请求从一个URL重定向到另一个URL的情况，而请求转发适用于在服务器内部将请求发送到其他资源进行处理的情况。</p> <h1 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="header-anchor">#</a> cookie 和 session 的区别</h1> <p>Cookie和Session是Web开发中常用的两种机制，用于在客户端和服务器之间存储和传递数据，但它们有以下关键区别：</p> <ol><li><p>存储位置：</p> <ul><li>Cookie：存储在客户端的浏览器中，以文本文件的形式保存在客户端。</li> <li>Session：存储在服务器端的内存或数据库中。</li></ul></li> <li><p>数据存储：</p> <ul><li>Cookie：通常用于存储少量的文本数据，每个Cookie的大小有限制。</li> <li>Session：可以存储更大量的数据，因为它在服务器端存储。</li></ul></li> <li><p>安全性：</p> <ul><li>Cookie：由于存储在客户端，存在安全风险，如Cookie被恶意篡改或盗取。</li> <li>Session：由于存储在服务器端，相对较安全，但仍需要注意保护Session ID。</li></ul></li> <li><p>生命周期：</p> <ul><li>Cookie：可以设置过期时间，可以是会话级的（关闭浏览器时过期）或长期的（在指定时间之前过期）。</li> <li>Session：默认情况下，会话会在客户端关闭后过期，也可以通过配置设置Session的过期时间。</li></ul></li> <li><p>存储方式：</p> <ul><li>Cookie：以名称值对(key-value)的形式存储在客户端，可以通过document.cookie在客户端JavaScript中访问。</li> <li>Session：使用一个唯一的Session ID来识别和跟踪用户会话，而实际的数据存储在服务器端。</li></ul></li> <li><p>跨域支持：</p> <ul><li>Cookie：可以在同一个域名下的不同路径之间共享，但存在同源策略的限制。</li> <li>Session：可以在同一个域名下的不同路径之间共享，并且不受同源策略的限制。</li></ul></li></ol> <p>总结起来，Cookie适用于存储少量的数据，并在客户端进行存储，可用于跟踪用户行为和身份验证。而Session适用于存储较大量的数据，并在服务器端进行存储，可用于保存用户的会话状态和敏感数据。在实际应用中，Cookie和Session常常结合使用，以满足不同的需求。</p> <h1 id="jsp-和-servlet"><a href="#jsp-和-servlet" class="header-anchor">#</a> Jsp 和 Servlet</h1> <p>JSP（JavaServer Pages）和Servlet是Java Web开发中两种常用的技术，用于构建动态的Web应用程序，它们有以下区别和特点：</p> <ol><li><p>功能：</p> <ul><li>JSP：JSP是一种在HTML页面中嵌入Java代码的技术。它允许开发者在JSP文件中直接编写Java代码，灵活地生成动态内容。JSP文件最终会被编译成Servlet。</li> <li>Servlet：Servlet是一种Java类，用于接收并处理HTTP请求。Servlet直接编写在Java类中，提供更加灵活和精细的控制，可以通过Java代码生成动态内容。</li></ul></li> <li><p>视图层：</p> <ul><li>JSP：JSP主要用于表示视图层，开发者可以在JSP文件中直接编写HTML和嵌入的Java代码，使得页面开发更加简洁、易读。</li> <li>Servlet：Servlet通常用于业务逻辑的处理和控制，它可以生成动态的响应内容，并将其发送回客户端。</li></ul></li> <li><p>开发方式：</p> <ul><li>JSP：开发者可以在JSP文件中使用HTML标记和嵌入的Java代码，这样更加符合页面设计和开发的习惯。</li> <li>Servlet：Servlet开发更加面向业务逻辑和后台处理，需要更多地使用Java语言，处理逻辑相对来说更加细致。</li></ul></li> <li><p>维护和分工：</p> <ul><li>JSP：由于JSP文件中存在嵌入的Java代码，可能会增加网页维护的难度。在团队开发中，可以通过前端开发人员负责JSP视图层的设计和开发，后端开发人员负责处理Servlet的逻辑。</li> <li>Servlet：Servlet相对于JSP来说，更加适合用于处理复杂的业务逻辑和后台请求。在团队开发中，后端开发人员通常负责Servlet的设计和开发。</li></ul></li></ol> <p>综合而言，JSP主要用于视图层的开发，适合于页面设计和习惯。Servlet主要用于业务逻辑和控制的处理，更加灵活和精细。在实际开发中，JSP和Servlet常常结合使用，通过相互调用和协作来构建完整的Web应用程序。</p> <h1 id="jsp-九大内置对象"><a href="#jsp-九大内置对象" class="header-anchor">#</a> JSP 九大内置对象</h1> <p>在JSP中，有九个内置对象可供直接使用，它们是：</p> <ol><li><p>request（请求对象）：表示客户端的HTTP请求，可用于获取请求参数、请求头信息等。</p></li> <li><p>response（响应对象）：表示服务器发送给客户端的HTTP响应，可用于设置响应头、发送响应内容等。</p></li> <li><p>out（输出对象）：表示向响应中输出内容的对象，可以使用它来向客户端输出HTML、文本等。</p></li> <li><p>session（会话对象）：表示用户的会话，在多个请求之间保持会话状态，可用于存储用户的信息。</p></li> <li><p>application（应用程序对象）：表示整个Web应用程序的上下文，可以在整个应用程序范围内共享数据。</p></li> <li><p>config（配置对象）：表示当前JSP页面的配置信息，如JSP的初始化参数等。</p></li> <li><p>page（页面对象）：表示当前JSP页面本身。</p></li> <li><p>pageContext（页面上下文对象）：表示当前JSP页面的上下文，可以获取其他内置对象。</p></li> <li><p>exception（异常对象）：表示发生在JSP页面中的异常，可以获得异常信息。</p></li></ol> <p>这些内置对象在JSP中默认可用，无需特殊操作即可直接使用。通过这些内置对象，开发者可以方便地获取请求信息、设置响应内容、控制会话状态等，使得JSP开发更加简洁和高效。</p> <h1 id="数据库"><a href="#数据库" class="header-anchor">#</a> 数据库</h1> <h2 id="_1-连接查询"><a href="#_1-连接查询" class="header-anchor">#</a> 1.连接查询</h2> <p>1.左连接 （左外连接）以左表为基准进行查询,左表数据会全部显示出来,右表如果和左表匹配的数据则显示相应字段的数据,如果不匹配,则显示为 NULL;</p> <p>2.右连接 （右外连接）以右表为基准进行查询,右表数据会全部显示出来,右表 如果和左表匹配的数据则显示相应字段的数据,如果不匹配,则显示为 NULL;</p> <h2 id="_2-聚合函数"><a href="#_2-聚合函数" class="header-anchor">#</a> 2.聚合函数</h2> <p>1.聚合函数 SQL 中提供的聚合函数可以用来统计、求和、求最值等等。
2.分类
COUNT：统计行数量
SUM：获取单个列的合计值
AVG：获取某个列的平均值
MAX：获取列的最大值
MIN：获取列的最小值</p> <h2 id="_3-sql-关键字"><a href="#_3-sql-关键字" class="header-anchor">#</a> 3.SQL 关键字</h2> <p>1.分页 MySQL 的分页关键词
limit SELECT * FROM student3 LIMIT 2,6;
查询学生表中数据，从第三条开始显示，显示6条
2.分组 MySQL 的分组关键字：
group by SELECT sex, count(*) FROM student3 GROUP BY sex;
3. 去重 去重关键字：
distinct select DISTINCT NAME FROM student3;</p> <h2 id="_4-sql-select-语句完整的执行顺序"><a href="#_4-sql-select-语句完整的执行顺序" class="header-anchor">#</a> 4.SQL Select 语句完整的执行顺序</h2> <p>查询中用到的关键词主要包含如下展示，并且他们的顺序依次为
form...on...left join...where...group by...avg()/sum()...having..select... order by...asc/desc...limit... from:
需要从哪个数据表检索数据
where: 过滤表中数据的条件
group by: 如何将上面过滤出的数据分组算结果
order by : 按照什么样的顺序来查看返回的数据</p> <h2 id="_5-数据库三范式"><a href="#_5-数据库三范式" class="header-anchor">#</a> 5.数据库三范式</h2> <p>第一范式：1NF 原子性，列或者字段不能再分，要求属性具有原子性，不可再分解；
第二范式：2NF 唯一性，一张表只说一件事，是对记录的惟一性约束，要求记录有惟一标识，
第三范式：3NF 直接性，数据不能存在传递关系，即每个属性都跟主键有直接关系，而不是间接关系。</p> <h2 id="_6-存储引擎"><a href="#_6-存储引擎" class="header-anchor">#</a> 6.存储引擎</h2> <p>1.MyISAM 存储引擎</p> <p>主要特点： MySQL5.5 版本之前的默认存储引擎 支持表级锁（表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁）；不支持事务，外键。 适用场景：对事务的完整性没有要求，或以 select、insert 为主的应用基本都可以选用MYISAM。在 Web、数据仓库中应用广泛。</p> <p>特点： 1、不支持事务、外键</p> <p>2、每个 myisam 在磁盘上存储为 3 个文件，文件名和表名相同，扩展名分别是.frm -------存储表定义 .MYD --------MYData，存储数据 .MYI --------MYIndex，存储索引</p> <p>2.InnoDB 存储引擎</p> <p>主要特点： MySQL5.5 版本之后的默认存储引擎； 支持事务； 支持行级锁（行级锁是 Mysql 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁）； 支持聚集索引方式存储数据</p> <h2 id="_7-数据库事务"><a href="#_7-数据库事务" class="header-anchor">#</a> 7.数据库事务</h2> <p>1.事务特性</p> <p>原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。</p> <p>一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，</p> <p>持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</p> <p>2.隔离级别</p> <p>（1）读未提交（read Uncommited）: 在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项目中基本不怎么用， 安全性太差；</p> <p>(2) 读已提交（read commited）: 这是大多数数据库默认的隔离级别，但是不是 MySQL 的默认隔离级别；这个隔离级别满足了简单的隔离要求：一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题；由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等问题（下面详细介绍这种问题，结合问题来理解隔离级别的含义）；</p> <p>(3 ) 可重复读（Repeatable read）： 这是 MySQL 的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数据；不过理论上，这会导致另一个棘手的问题：幻读 （PhantomRead）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB 和Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p> <p>(4) 可串行化（serializable）： 事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个</p> <h2 id="_8-索引"><a href="#_8-索引" class="header-anchor">#</a> 8.索引</h2> <p>1.索引的概念和优点（了解）</p> <p>概念： 索引存储在内存中，为服务器存储引擎为了快速找到记录的一种数据结构。索引的主要作用是加快数据查找速度，提高数据库的性能。</p> <p>优点：</p> <p>(1) 创建唯一性索引，保证数据库表中每一行数据的唯一性</p> <p>(2) 大大加快数据的检索速度，这也是创建索引的最主要的原因</p> <p>(3) 加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p> <p>(4) 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p> <p>2.索引的分类（必会）</p> <p>(1) 普通索引：最基本的索引，它没有任何限制。</p> <p>(2) 唯一索引：与普通索引类似，不同的就是索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p> <p>(3) 主键索引：它是一种特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用 primary key 来约束。</p> <p>(4) 联合索引（又叫复合索引）：多个字段上建立的索引，能够加速复合查询条件的检索。</p> <p>(5) 全文索引：老版本 MySQL 自带的全文索引只能用于数据库引擎为MyISAM 的数据表，新版本 MySQL 5.6 的 InnoDB 支持全文索引。默认MySQL不支持中文全文检索，可以通过扩展 MySQL，添加中文全文检索或为中文内容表提供一个对应的英文索引表的方式来支持中文。</p> <p>3.索引的底层实现原理</p> <ol><li>索引结构 索引是在 Mysql 的存储引擎(InnoDB,MyISAM)层中实现的, 而不是在服务层实现的. 所以每种存储引擎的索引都不一定完全相同, 也不是所有的存储引擎都支持所有的索引类型的, Mysql 目前提供了以下 4 种索引:</li></ol> <p>B+Tree 索引: 最常见的索引类型, 大部分索引都支持 B+树索引.</p> <p>Hash 索引: 只有 Memory 引擎支持, 使用场景简单.</p> <p>R-Tree 索引(空间索引): 空间索引是 MyISAM 引擎的一个特殊索引类型, 主要地理空间数据, 使用也很少</p> <p>S-Full-text(全文索引): 全文索引也是 MyISAM 的一个特殊索引类型, 主要用于全文索引, InnoDB 从 Mysql5.6 版本开始支持全文索引</p> <ol start="4"><li>如何避免索引失效</li></ol> <p>(1) 范围查询, 右边的列不能使用索引, 否则右边的索引也会失效</p> <p>(2) 不要在索引上使用运算, 否则索引也会失效.</p> <p>(3) 字符串不加引号, 造成索引失效.</p> <p>(4) 尽量使用覆盖索引, 避免 select *, 这样能提高查询效率.</p> <p>(5) or 关键字连接</p> <h2 id="_9-数据库锁-高薪常问"><a href="#_9-数据库锁-高薪常问" class="header-anchor">#</a> 9.数据库锁(高薪常问)</h2> <p>1.行锁和表锁</p> <p>1.主要是针对锁粒度划分的，一般分为：行锁、表锁、库锁 行锁：访问数据库的时候，锁定整个行数据，防止并发错误。 表锁：访问数据库的时候，锁定整个表数据，防止并发错误。</p> <p>2.行锁 和 表锁 的区别：</p> <p>表锁： 开销小，加锁快，不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低</p> <p>行锁： 开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</p> <p>2.悲观锁和乐观锁</p> <p>（1）悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p> <p>（2）乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。 乐 观 锁 适 用 于 多 读 的 应 用 类 型 ， 这 样 可 以 提 高 吞 吐 量 ， 像 数 据库如果提供类似于write_condition 机制的其实都是提供的乐观锁</p> <h2 id="_10-mysql-优化"><a href="#_10-mysql-优化" class="header-anchor">#</a> 10.MySql 优化</h2> <p>索引优化</p> <p>表优化</p> <p>sql慢查询优化</p> <p>(1) 定位执行效率慢的 sql 语句.</p> <p>命令:show status like 'Com',通过这条命令, 我们可以知道当前数据库是以查询为主还是更新为主. 如果是查询为主, 就重点查询; 如果增删改多就重点优化写入操作.</p> <p>explain + sql语句查询sql执行过程, 通过执行计划，我们能得到哪些信息：</p> <p>A：哪些步骤花费的成本比较高</p> <p>B：哪些步骤产生的数据量多，数据量的多少用线条的粗细表示，很直观</p> <p>C：这条sql语句是否走索引</p> <p>show profile 分析 SQL,可以查看所有 sql 语句的执行效率(所用时间). 前提是这个命令需要被打开, 严格的说也就是打开这个命令后执行的所有 sql 语句, 它都能记录下执行时间, 并展示出来. 可以通过这个命令分析哪些 sql 语句执行效率低. 耗时长, 就更有针对性的优化这条 sql.</p> <p>慢查询日志(常用的工具)</p> <p>慢 查 询 日 志 记 录 了 所 有 执 行 时 间 超 过 参 数 long_query_time 的sql 语句的日志, long_query_time 默认为 10 秒(可以通过配置文件设置), 日志保存在 /var/lib/mysql/目录下, 有个 slow_query.log 文件</p> <p>(2) 优化索引</p> <p>2.1 索引设计原则</p> <p>索引的设计需要遵循一些已有的原则, 这样便于提升索引的使用效率, 更高效的使用索引.</p> <p>★对查询频次较高, 且数据量比较大的表, 建立索引.</p> <p>★ 索引字段的选择, 最佳候选列应当从 where 子句的条件中提取, 如果where 子句中的组合比较多, 那么应当挑选最常用, 过滤效果最好的列的组合.</p> <p>★ 使用唯一索引, 区分度越高, 使用索引的效率越高.</p> <p>★ 索引并非越多越好, 如果该表赠,删,改操作较多, 慎重选择建立索引, 过多索引会降低表维护效率.  使用短索引, 提高索引访问时的 I/O 效率, 因此也相应提升了 Mysql 查询效率.</p> <p>★ 如果 where 后有多个条件经常被用到, 建议建立符合 索引, 复合索引需要遵循最左前缀法则, N 个列组合而成的复合索引, 相当于创建了 N 个索引. 复合索引命名规则 index_表名_列名 1_列名 2_列明 3 比如:create index idx_seller_name_sta_addr on tb_seller(name, status, address)</p> <p>2.2 避免索引失效</p> <p>★ 如果在查询的时候, 使用了复合索引, 要遵循最左前缀法则, 也就是查询从索引的最左列开始, 并且不能跳过索引中的列.</p> <p>★ 尽量不要在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p> <p>★ 应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p> <p>★ 不做列运算where age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数.计算表达式等, 都会是索引失效.</p> <p>★ 查询 like，如果是 ‘%aaa’ 也会造成索引失效.  应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描</p> <p>（3) Sql 语句调优</p> <p>★ 根据业务场景建立复合索引只查询业务需要的字段，如果这些字段被索引覆盖，将极大的提高查询效率.</p> <p>★ 多表连接的字段上需要建立索引，这样可以极大提高表连接的效率.</p> <p>★ where 条件字段上需要建立索引, 但 Where 条件上不要使用运算函数，以免索引失效.  排序字段上, 因为排序效率低, 添加索引能提高查询效率.</p> <p>★ 优化 insert 语句: 批量列插入数据要比单个列插入数据效率高.</p> <p>★ 优化 order by 语句: 在使用 order by 语句时, 不要使用 select *, select 后面要查有索引的列, 如果一条 sql 语句中对多个列进行排序, 在业务允许情况下, 尽量同时用升序或同时用降序. *</p> <p>★ 优化 group by 语句: 在我们对某一个字段进行分组的时候, Mysql 默认就进行了排序, 但是排序并不是我们业务所需的, 额外的排序会降低效率. 所以在用的时候可以禁止排序, 使用 order by null 禁用.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>select age, count() from emp group by age order by null
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>★ 尽量避免子查询, 可以将子查询优化为 join 多表连接查询</p> <p>(4)合理的数据库设计</p> <p>根据数据库三范式来进行表结构的设计。设计表结构时，就需要考虑如何设计才能更有效的查询, 遵循数据库三范式：</p> <p>i. 第一范式：数据表中每个字段都必须是不可拆分的最小单元，也就是确保每一列的原子性；</p> <p>ii. 第二范式：满足一范式后，表中每一列必须有唯一性，都必须依赖于主键；</p> <p>iii. 第三范式：满足二范式后，表中的每一列只与主键直接相关而不是间接相关(外键也是直接相关)，字段没有冗余。</p> <p>注意：没有最好的设计，只有最合适的设计，所以不要过分注重理论。三范式可以作为一个基本依据，不要生搬硬套。有时候可以根据场景合理地反规范化：</p> <p>A：保留冗余字段。当两个或多个表在查询中经常需要连接时，可以在其中一个表上增加若干冗余的字段，以 避免表之间的连接过于频繁，一般在冗余列的数据不经常变动的情况下使用。</p> <p>B：增加派生列。派生列是由表中的其它多个列的计算所得，增加派生列可以减少统计运算，在数据汇总时可以大大缩短运算时间, 前提是这个列经常被用到, 这也就是反第三范式。</p> <p>C：分割表。 数据表拆分：主要就是垂直拆分和水平拆分。 水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。 垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。</p> <p>D: 字段设计 1. 表的字段尽可能用 NOT NULL 2. 字段长度固定的表查询会更快 3. 把数据库的大表按时间或一些标志分成小表</p> <h1 id="mybatis-框架"><a href="#mybatis-框架" class="header-anchor">#</a> Mybatis 框架</h1> <h2 id="_1-1-谈一谈你对-mybatis-框架的理解"><a href="#_1-1-谈一谈你对-mybatis-框架的理解" class="header-anchor">#</a> 1.1 谈一谈你对 Mybatis 框架的理解</h2> <p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p> <h2 id="_1-2-在-mybatis-中-和-的区别是什么"><a href="#_1-2-在-mybatis-中-和-的区别是什么" class="header-anchor">#</a> 1.2 在 mybatis 中,${} 和 #{} 的区别是什么?</h2> <p>{} 是占位符，预编译处理，${}是字符串替换。</p> <p>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的set 方法来赋值； Mybatis 在处理${}时，就是把${}替换成变量的值。 使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p> <h2 id="_1-3-mybatis-编程步骤是什么样的"><a href="#_1-3-mybatis-编程步骤是什么样的" class="header-anchor">#</a> 1.3 MyBatis 编程步骤是什么样的？</h2> <p>1、 创建 SqlSessionFactory</p> <p>2、 通过 SqlSessionFactory 创建 SqlSession</p> <p>3、 通过 sqlsession 执行数据库操作</p> <p>4、 调用 session.commit()提交事务</p> <p>5、 调用 session.close()关闭会话</p> <h2 id="_1-4-在-mybatis-中-resulttype-和-resultmap-的区别是什么"><a href="#_1-4-在-mybatis-中-resulttype-和-resultmap-的区别是什么" class="header-anchor">#</a> 1.4 在 mybatis 中,resultType 和 ResultMap 的区别是什么?</h2> <p>如果数据库结果集中的列名和要封装实体的属性名完全一致的话用resultType 属性</p> <p>如果数据库结果集中的列名和要封装实体的属性名有不一致的情况用resultMap属性，通过 resultMap 手动建立对象关系映射，resultMap 要配置一下表和类的一一对应关系，所以说就算你的字段名和你的实体类的属性名不一样也没关系，都会给你映射出来</p> <h2 id="_1-5-在-mybatis-中你知道的动态-sql-的标签有哪些-作用分别是什么"><a href="#_1-5-在-mybatis-中你知道的动态-sql-的标签有哪些-作用分别是什么" class="header-anchor">#</a> 1.5 在 Mybatis 中你知道的动态 SQL 的标签有哪些?作用分别是什么?</h2> <ol><li>if 是为了判断传入的值是否符合某种规则,比如是否不为空.</li> <li>where 标签可以用来做动态拼接查询条件,当和if 标签配合的时候,不用显示的声明类型 where 1 = 1 这种无用的条件</li> <li>foreach 标签可以把传入的集合对象进行遍历,然后把每一项的内容作为参数传到 sql 语句</li> <li>include 可以把大量的重复代码整理起来,当使用的时候直接include即可,减少重复代码的编写;</li> <li>适用于更新中,当匹配某个条件后,才会对该字段进行跟新操作</li></ol> <h2 id="_1-6-谈一下你对-mybatis-缓存机制的理解"><a href="#_1-6-谈一下你对-mybatis-缓存机制的理解" class="header-anchor">#</a> 1.6 谈一下你对 mybatis 缓存机制的理解?</h2> <p>Mybatis 有两级缓存，一级缓存是 SqlSession 级别的，默认开启，无法关闭；二级缓存是 Mapper 级别的，二级缓存默认是没有开启的，但是手动开启</p> <ol><li><p>一级缓存：基础 PerpetualCache 的 HashMap 本地缓存，其存储作用域为Session, 当 Session flush 或 close 之后，Session 中的所有 Cache 就将清空</p></li> <li><p>二级缓存其存储作用域为 Mapper(Namespace），使用二级缓存属性类需要实现Serializable 序列化接口</p></li> <li><p>对于缓存数据更新机制，当某一个作用域(一级缓存Session/二级缓存Namespaces) 的进行了 C(增加)/U(更新)/D(删除)操作后，默认该作用域下所有 select 中的缓存将被clear. 需要在 setting 全局参数中配置开启二级缓存，如下 conf.xml 配置：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cacheEnavled<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>默认是false，关闭二级缓存    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>当我们的配置文件配置了 cacheEnabled=true 时，就会开启二级缓存，二级缓存是mapper 级别的，如果你配置了二级缓存，那么查询数据的顺序应该为：二级缓存→一级缓存→数据库</p></li></ol> <h1 id="spring-框架"><a href="#spring-框架" class="header-anchor">#</a> Spring 框架</h1> <h2 id="_2-1-spring的两大核心是什么"><a href="#_2-1-spring的两大核心是什么" class="header-anchor">#</a> 2.1 Spring的两大核心是什么?</h2> <p>谈一谈你对IOC的理解?</p> <p>谈一谈你对DI的理解?</p> <p>谈一谈你对 AOP 的理解?</p> <ol><li><p>Spring 的两大核心是：IOC（控制反转）和 AOP（面向切面编程）DI（依赖注入）</p></li> <li><p>IOC 的意思是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到 Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。最直观的表达就是，IOC 让对象的创建不用去 new 了，可以由 spring 根据我们提供的配置文件自动生产，我们需要对象的时候，直接从 Spring 容器中获取即可.</p></li> <li><p>Spring 的配置文件中配置了类的字节码位置及信息, 容器生成的时候加载配置文件识别字节码信息, 通过反射创建类的对象.</p></li> <li><p>Spring 的 IOC 有三种注入方式 ：构造器注入, setter 方法注入, 根据注解注入。</p></li> <li><p>DI 的意思是依赖注入，和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖 Io c 容器来动态注入对象需要的外部资源</p></li> <li><p>AOP，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect）.</p></li> <li><p>SpringAOP 使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP 对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。5. Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和CGLIB 动态代理：</p> <p>(1) JDK 动态代理只提供接口代理，不支持类代理，核心 InvocationHandler 接口和Proxy 类，InvocationHandler 通过 invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起，Proxy 利用 InvocationHandler 动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</p> <p>(2) 如果代理类没有实现 InvocationHandler 接口，那么 Spring AOP 会选择使用CGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现 AOP。CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用 CGLIB 做动态代理的。</p></li></ol> <h2 id="_2-2-spring-的生命周期"><a href="#_2-2-spring-的生命周期" class="header-anchor">#</a> 2.2 Spring 的生命周期?</h2> <ol><li>实例化一个 Bean，也就是我们通常说的 new</li> <li>按照 Spring 上下文对实例化的 Bean 进行配置，也就是 IOC 注入</li> <li>如果这个 Bean 实现 dao 了 BeanNameAware 接口，会调用它实现的setBeanName(String beanId)方法，此处传递的是 Spring 配置文件中Bean 的ID</li> <li>如果这个 Bean 实现了 BeanFactoryAware 接口，会调用它实现的setBeanFactory()，传递的是 Spring 工厂本身（可以用这个方法获取到其他 Bean）</li> <li>如果这个 Bean 实现了 ApplicationContextAware 接口，会调用setApplicationContext(ApplicationContext)方法，传入 Spring 上下文，该方式同样可以实现步骤 4，但比 4 更好，以为 ApplicationContext 是 BeanFactory 的子接口，有更多的实现方法</li> <li>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用 postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor 经常被用作是 Bean 内容的更改，并且由于这个是在 Bean 初始化结束时调用After 方法，也可用于内存或缓存技术</li> <li>如果这个 Bean在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法</li> <li>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用 postAfterInitialization(Object obj, String s)方法 注意：以上工作完成以后就可以用这个 Bean 了，那这个 Bean 是一个single 的，所以一般情况下我们调用同一个 ID 的 Bean 会是在内容地址相同的实例</li> <li>当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 接口，会调用其实现的 destroy 方法</li> <li>最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法</li></ol> <h2 id="_2-3-spring-支持-bean-的作用域有几种吗-每种作用域是什么样的"><a href="#_2-3-spring-支持-bean-的作用域有几种吗-每种作用域是什么样的" class="header-anchor">#</a> 2.3 Spring 支持 bean 的作用域有几种吗? 每种作用域是什么样的?</h2> <p>Spring 支持如下 5 种作用域：</p> <p>（1）singleton：默认作用域，单例 bean，每个容器中只有一个bean 的实例。</p> <p>（2）prototype：每次请求都会为 bean 创建实例。</p> <p>（3）request：为每一个 request 请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。</p> <p>（4）session：与 request 范围类似，同一个 session 会话共享一个实例，不同会话使用不同的实例。</p> <p>（5）global-session：全局作用域，所有会话共享一个实例。如果想要声明让所有会话共享的存储变量的话，那么这全局变量需要存储在 global-session 中</p> <h2 id="_2-4-beanfactory-和-applicationcontext-有什么区别"><a href="#_2-4-beanfactory-和-applicationcontext-有什么区别" class="header-anchor">#</a> 2.4 BeanFactory 和 ApplicationContext 有什么区别</h2> <p>BeanFactory： Spring 最顶层的接口,实现了 Spring 容器的最基础的一些功能, 调用起来比较麻烦, 一般面向 Spring 自身使用 BeanFactory 在启动的时候不会去实例化 Bean，从容器中拿Bean 的时候才会去实例化</p> <p>ApplicationContext： 是 BeanFactory 的子接口,扩展了其功能, 一般面向程序员身使用ApplicationContext 在启动的时候就把所有的 Bean 全部实例化了</p> <h2 id="_2-5-spring-框架中都用到了哪些设计模式"><a href="#_2-5-spring-框架中都用到了哪些设计模式" class="header-anchor">#</a> 2.5 Spring 框架中都用到了哪些设计模式?</h2> <ol><li>工厂模式：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例</li> <li>单例模式：Bean 默认为单例模式</li> <li>代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术</li> <li>模板方法 ：用来解决代码重 复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate</li> <li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所 有 依 赖 于 它 的 对 象 都 会 得 到 通 知 被 制 动 更 新 ， 如 Spring 中listener 的实现--ApplicationListener</li></ol> <h2 id="_2-6-spring-事务的实现方式和实现原理"><a href="#_2-6-spring-事务的实现方式和实现原理" class="header-anchor">#</a> 2.6 Spring 事务的实现方式和实现原理</h2> <p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过 binlog 或者redolog实现的。 spring 事务实现主要有两种方法</p> <p>1、编程式，beginTransaction()、commit()、rollback()等事务管理相关的方法</p> <p>2、声明式，利用注解 Transactional 或者 aop 配置</p> <h2 id="_2-7-spring-的对象默认是单例的还是多例的-单例-bean-存不存在线程安全问题呢"><a href="#_2-7-spring-的对象默认是单例的还是多例的-单例-bean-存不存在线程安全问题呢" class="header-anchor">#</a> 2.7 Spring 的对象默认是单例的还是多例的? 单例 bean 存不存在线程安全问题呢?</h2> <ol><li><p>在 spring 中的对象默认是单例的，但是也可以配置为多例。</p></li> <li><p>单例 bean 对象对应的类存在可变的成员变量并且其中存在改变这个变量的线程时，多线程操作该 bean 对象时会出现线程安全问题。</p> <p>原因是：多线程操作如果改变成员变量，其他线程无法访问该 bean 对象，造成数据混乱。</p> <p>解决办法：在 bean 对象中避免定义可变成员变量； 在 bean 对象中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中</p></li></ol> <h2 id="_2-8-resource-和-autowired-依赖注入的区别是什么-qualifier-使用场景是什么"><a href="#_2-8-resource-和-autowired-依赖注入的区别是什么-qualifier-使用场景是什么" class="header-anchor">#</a> 2.8 @Resource 和@Autowired 依赖注入的区别是什么? @Qualifier 使用场景是什么?</h2> <p>@Resource 只能放在属性上，表示先按照属性名匹配 IOC 容器中对象 id 给属性注入值若没有成功，	会继续根据当前属性的类型匹配 IOC 容器中同类型对象来注入值若指定了 name 属性@Resource(name = &quot;对象 id&quot;)，则只能按照对象id 注入值。@Autowird 放在属性上：表示先按照类	型给属性注入值如果 IOC 容器中存在多个与属性同类型的对象，则会按照属性名注入值 也可以配合@Qualifier(&quot;IOC 容器中对象 id&quot;)注解直接按照名称注入值。放在方法上：表示自动执行当前方法，如果方法有参数，会自动从IOC 容器中寻找同类型的对象给参数传值 也可以在参数上添加@Qualifier(&quot;IOC 容器中对象 id&quot;)注解按照名称寻找对象给参数传值。</p> <p>@Qualifier 使用场景： @Qualifier(&quot;IOC 容器中对象 id&quot;)可以配合@Autowird 一起使用, 表示根据指定的 id 在 Spring 容器中匹配对象</p> <h2 id="_2-9-spring-的事务传播行为"><a href="#_2-9-spring-的事务传播行为" class="header-anchor">#</a> 2.9 Spring 的事务传播行为</h2> <p>spring 事务的传播行为说的是，当多个事务同时存在的时候，spring 如何处理这些事务的行为。</p> <p>备注(方便记忆): propagation 传播 require 必须的/suppor 支持/mandatory 强制托管/requires-new需要新建/not -supported 不支持/never 从不/nested 嵌套的</p> <p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p> <p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p> <p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p> <p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p> <p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p> <p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p> <p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按 REQUIRED 属性执行</p> <h2 id="_2-10-spring-中的隔离级别"><a href="#_2-10-spring-中的隔离级别" class="header-anchor">#</a> 2.10 Spring 中的隔离级别</h2> <p>ISOLATION 隔离的意思</p> <p>① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</p> <p>② ISOLATION_READ_UNCOMMITTED：读未提交，允许另外一个事务可以看到这个事务未提交的数据。</p> <p>③ ISOLATION_READ_COMMITTED：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。解决脏读问题</p> <p>④ ISOLATION_REPEATABLE_READ：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。行锁</p> <p>⑤ ISOLATION_SERIALIZABLE：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。表锁</p> <h1 id="springmvc-框架"><a href="#springmvc-框架" class="header-anchor">#</a> SpringMVC 框架</h1> <h2 id="_3-1-谈一下你对-springmvc-框架的理解"><a href="#_3-1-谈一下你对-springmvc-框架的理解" class="header-anchor">#</a> 3.1 谈一下你对 SpringMVC 框架的理解</h2> <p>​	SpringMVC 是一个基于 Java 的实现了 MVC 设计模式的请求驱动类型的轻量级Web框架，通过把 Model，View，Controller 分离，将 web 层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p> <p>​	在我看来,SpringMVC 就是将我们原来开发在 servlet 中的代码拆分了,一部分由SpringMVC 完成,一部分由我们自己完成</p> <h2 id="_3-2-springmvc-主要组件"><a href="#_3-2-springmvc-主要组件" class="header-anchor">#</a> 3.2 SpringMVC 主要组件</h2> <p>前端控制器 DispatcherServlet：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p> <p>处理器映射器 HandlerMapping：根据请求的 URL 来查找 Handler</p> <p>处理器适配器 HandlerAdapter：负责执行 Handler</p> <p>处理器 Handler：处理业务逻辑的 Java 类</p> <p>视图解析器 ViewResolver：进行视图的解析，根据视图逻辑名将ModelAndView解析成真正的视图（view）</p> <p>视图 View：View 是一个接口， 它的实现类支持不同的视图类型，如jsp，freemarker，pdf 等等</p> <h2 id="_3-3-谈一下-springmvc-的执行流程以及各个组件的作用"><a href="#_3-3-谈一下-springmvc-的执行流程以及各个组件的作用" class="header-anchor">#</a> 3.3 谈一下 SpringMVC 的执行流程以及各个组件的作用</h2> <ol><li>用户发送请求到前端控制器（DispatcherServlet）</li> <li>前 端 控 制 器 （ DispatcherServlet ） 收 到 请 求 调用处理器映射器（HandlerMapping），去查找处理器（Handler）</li> <li>处理器映射器（HandlerMapping）找到具体的处理器(可以根据xml 配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li> <li>前端控制器（DispatcherServlet）调用处理器映射器（HandlerMapping）</li> <li>处理器适配器（HandlerAdapter）去调用自定义的处理器类(Controller，也叫后端控制器)。</li> <li>自定义的处理器类(Controller，也叫后端控制器)将得到的参数进行处理并返回结果给处理器映射器（HandlerMapping）</li> <li>处 理 器 适 配 器 （ HandlerAdapter ） 将 得 到 的 结 果返回给前端控制器（DispatcherServlet）</li> <li>DispatcherServlet( 前 端 控 制 器 ) 将 ModelAndView 传给视图解析器(ViewReslover)</li> <li>视图解析器(ViewReslover)将得到的参数从逻辑视图转换为物理视图并返回给前端控制器（DispatcherServlet）</li> <li>前端控制器（DispatcherServlet）调用物理视图进行渲染并返回</li> <li>前端控制器（DispatcherServlet）将渲染后的结果返回</li></ol> <h2 id="_3-4-说一下-springmvc-支持的转发和重定向的写法"><a href="#_3-4-说一下-springmvc-支持的转发和重定向的写法" class="header-anchor">#</a> 3.4 说一下 SpringMVC 支持的转发和重定向的写法</h2> <ol><li>转发： forward 方式:在返回值前面加&quot;forward:&quot;,比如&quot;”&quot;forward:user.do?name=method4&quot;</li></ol> <ol start="2"><li>重定向: redirect 方式：在返回值前面加 redirect:, 比如&quot;redirect:http://www.baidu.com&quot;</li></ol> <h2 id="_3-5-springmvc-的常用注解"><a href="#_3-5-springmvc-的常用注解" class="header-anchor">#</a> 3.5 SpringMVC 的常用注解</h2> <ol><li><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p></li> <li><p>@RequestBody：注解实现接收 http 请求的 json 数据，将 json 转换为java 对象。</p></li> <li><p>@ResponseBody：注解实现将 conreoller 方法返回对象转化为json 对象响应给客户。</p></li> <li><p>@PathVariable 用户从 url 路径上获取指定参数，标注在参数前@PathVariabel(&quot; 要获取的参数名&quot;)。</p></li> <li><p>@RequestParam: 标注在方法参数之前，用于对传入的参数做一些限制，支持三个属性: - value：默认属性，用于指定前端传入的参数名称 - required：用于指定此参数是否必传 - defaultValue：当参数为非必传参数且前端没有传入参数时，指定一个默认值</p></li> <li><p>@ControllerAdvice 标注在一个类上，表示该类是一个全局异常处理的类。</p></li> <li><p>@ExceptionHandler(Exception.class) 标注在异常处理类中的方法上，表示该方法可以处理的异常类型</p></li></ol> <h2 id="_3-6-谈一下-springmvc-统一异常处理的思想和实现方式"><a href="#_3-6-谈一下-springmvc-统一异常处理的思想和实现方式" class="header-anchor">#</a> 3.6 谈一下 SpringMVC 统一异常处理的思想和实现方式</h2> <p>使用 SpringMVC 之后,代码的调用者是 SpringMVC 框架,也就是说最终的异常会抛到框架中,然后由框架指定异常处理类进行统一处理</p> <p>方式一: 创建一个自定义异常处理器(实现 HandlerExceptionResolver 接口),并实现里面的异常处理方法,然后将这个类交给 Spring 容器管理</p> <p>方式二: 在类上加注解(@ControllerAdvice)表明这是一个全局异常处理类在 方 法 上 加 注 解 (@ExceptionHandler), 在 ExceptionHandler 中有一个value 属性,可以指定可以处理的异常类型</p> <h2 id="_3-7-在-springmvc-中-如果想通过转发将数据传递到前台-有几种写法"><a href="#_3-7-在-springmvc-中-如果想通过转发将数据传递到前台-有几种写法" class="header-anchor">#</a> 3.7 在 SpringMVC 中, 如果想通过转发将数据传递到前台,有几种写法?</h2> <p>方式一：直接使用 request 域进行数据的传递</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> request<span class="token punctuation">.</span><span class="token function">setAttirbuate</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>方式二：使用 Model 进行传值，底层会将数据放入 request 域进行数据的传递</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>model<span class="token punctuation">.</span><span class="token function">addAttribuate</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>方式三：使用 ModelMap 进行传值，底层会将数据放入 request 域进行数据的传递</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>modelmap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>方式四：借用 ModelAndView 在其中设置数据和视图</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>mv<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> mv<span class="token punctuation">.</span><span class="token function">setView</span><span class="token punctuation">(</span><span class="token string">&quot;success&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> mv<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>3.8 在 SpringMVC 中拦截器的使用步骤是什么样的?</p> <p>1 定义拦截器类:</p> <p>SpringMVC 为 我 们 提 供 了 拦 截 器 规 范 的 接 口 , 创建一个类实现HandlerInterceptor,重写接口中的抽象方法; preHandle 方法：在调用处理器之前调用该方法，如果该方法返回true 则请求继续向下进行，否则请求不会继续向下进行,处理器也不会调用 postHandle 方法：在调用完处理器后调用该方法 afterCompletion 方法：在前端控制器渲染页面完成之后调用此方法</p> <p>2 注册拦截器:</p> <p>在 SpringMVC 核心配置文件中注册自定义的拦截器</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>拦截路径规则<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>不拦截路径规则<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>自定义拦截器的类全限定名<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_3-9-在-springmvc-中文件上传的使用步骤是什么样的-前台三要素是什么"><a href="#_3-9-在-springmvc-中文件上传的使用步骤是什么样的-前台三要素是什么" class="header-anchor">#</a> 3.9 在 SpringMVC 中文件上传的使用步骤是什么样的? 前台三要素是什么?</h2> <p>文件上传步骤:</p> <p>1.加入文件上传需要的 commons-fileupload 包</p> <p>2.配置文件上传解析器,springmvc 的配置文件的文件上传解析器的id 属性必须为multipartResolver 3.后端对应的接收文件的方法参数类型必须为 MultipartFile,参数名称必须与前端的 name 属性保持一致</p> <p>文件上传前端三要素:</p> <p>1.form 表单的提交方式必须为 post</p> <p>2.enctype 属性需要修改为:multipart/form-data</p> <p>3.必须有一个 type 属性为 file 的 input 标签,其中需要有一个name 属性;如果需要上传多个文件需要添加 multiple 属性</p> <h2 id="_3-10-springmvc-中如何解决-get-post-请求中文乱码问题"><a href="#_3-10-springmvc-中如何解决-get-post-请求中文乱码问题" class="header-anchor">#</a> 3.10 SpringMVC 中如何解决 GET|POST 请求中文乱码问题？</h2> <p>（1）解决 post 请求乱码问题：在 web.xml 中配置一个 CharacterEncodingFilter 过滤器，设置成 utf-8；</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fil</span>
<span class="token attr-name">ter-class</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>utf-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>(2) get 请求中文参数出现乱码解决方法有两个：</p> <p>①修改 tomcat 配置文件添加编码与工程编码一致，如下：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>②另外一种方法对参数进行重新编码：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>String userName= new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>ISO8859-1 是 tomcat 默认编码，需要将 tomcat 编码后的内容按 utf-8 编码。</p> <h1 id="dubbo"><a href="#dubbo" class="header-anchor">#</a> Dubbo</h1> <h2 id="_4-1-什么是-dubbo"><a href="#_4-1-什么是-dubbo" class="header-anchor">#</a> 4.1 什么是 dubbo</h2> <p>​	工作在 soa 面向服务分布式框架中的服务管理中间件。</p> <p>​	Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。</p> <p>​	它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。关于注册中心、协议支持、服务监控等内容。</p> <p>​	Dubbo 使用的是缺省协议， 采用长连接和 nio 异步通信， 适合小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p> <p>​	反之， dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p> <h2 id="_4-2-dubbo-的实现原理"><a href="#_4-2-dubbo-的实现原理" class="header-anchor">#</a> 4.2 Dubbo 的实现原理</h2> <img src="/java/Snipaste_2023-09-08_13-39-35.png" alt="mixureSecure"> <h2 id="_4-3-节点角色说明"><a href="#_4-3-节点角色说明" class="header-anchor">#</a> 4.3 节点角色说明</h2> <p>Provider: 暴露服务的服务提供方。</p> <p>Consumer: 调用远程服务的服务消费方。</p> <p>Registry: 服务注册与发现的注册中心。</p> <p>Monitor: 统计服务的调用次调和调用时间的监控中心。</p> <p>Container: 服务运行容器。</p> <h2 id="_4-4-调用关系说明"><a href="#_4-4-调用关系说明" class="header-anchor">#</a> 4.4 调用关系说明</h2> <ol><li>服务容器负责启动，加载，运行服务提供者。</li> <li>服务提供者在启动时，向注册中心注册自己提供的服务。</li> <li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li> <li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li> <li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li> <li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol> <h2 id="_4-5-在实际开发的场景中应该如何选择-rpc-框架"><a href="#_4-5-在实际开发的场景中应该如何选择-rpc-框架" class="header-anchor">#</a> 4.5 在实际开发的场景中应该如何选择 RPC 框架</h2> <p>SpringCloud ： Spring 全家桶，用起来很舒服，只有你想不到，没有它做不到。可惜因为发布的比较晚，国内还没出现比较成功的案例，大部分都是试水，不过毕竟有Spring作背景，还是比较看好。</p> <p>Dubbox：相对于 Dubbo 支持了 REST，估计是很多公司选择Dubbox 的一个重要原因之一，但如果使用 Dubbo 的 RPC 调用方式，服务间仍然会存在 API 强依赖，各有利弊，懂的取舍吧。</p> <p>Thrift： 如果你比较高冷，完全可以基于 Thrift 自己搞一套抽象的自定义框架吧。</p> <p>Hessian：如果是初创公司或系统数量还没有超过 5 个，推荐选择这个，毕竟在开发速度.运维成本.上手难度等都是比较轻量.简单的，即使在以后迁移至 SOA，也是无缝迁移。</p> <p>rpcx/gRPC：在服务没有出现严重性能的问题下，或技术栈没有变更的情况下，可能一直不会引入，即使引入也只是小部分模块优化使用。</p> <h1 id="_5-zookeeper"><a href="#_5-zookeeper" class="header-anchor">#</a> 5. Zookeeper</h1> <h2 id="_5-1-zookeeper-是什么"><a href="#_5-1-zookeeper-是什么" class="header-anchor">#</a> 5.1 Zookeeper 是什么</h2> <p>​	Zookeeper 是一个分布式协调服务的开源框架, 主要用来解决分布式集群中应用系统的一致性问题, 例如怎样避免同时操作同一数据造成脏读的问题.</p> <p>​	ZooKeeper 本质上是一个分布式的小文件存储系统. 提供基于类似于文件系统的目录树方式的数据存储, 并且可以对树中的节点进行有效管理. 从而用来维护和监控你存储的数据的状态变化. 通过监控这些数据状态的变化，从而可以达到基于数据的集群管理.</p> <p>​	在大数据生态系统里，很多组件的命名都是某种动物，比如 hadoop 就是大象, hive就是蜜蜂, 而 Zookeeper 就是动物管理员.</p> <h2 id="_5-2-zookeeper-的数据模型"><a href="#_5-2-zookeeper-的数据模型" class="header-anchor">#</a> 5.2 Zookeeper 的数据模型</h2> <p>★ ZK 本质上是一个分布式的小文件存储系统.</p> <p>★ ZK 表现为一个分层的文件系统目录树结构, 既能存储数据, 而且还能像目录一样有子节点. 每个节点可以存最多 1M 左右的数据.</p> <p>★ 每个节点称做一个 Znode, 每个 Znode 都可以通过其路径唯一标识.</p> <p>★ 而且客户端还能给节点添加 watch, 也就是监听器, 可以监听节点的变化, 这个功能常在实际开发中作为监听服务器集群机器上下线操作.</p> <h3 id="_5-2-1-节点结构"><a href="#_5-2-1-节点结构" class="header-anchor">#</a> 5.2.1 节点结构</h3> <img src="/java/Snipaste_2023-09-08_14-09-23.png" alt="mixureSecure"> <p>图中的每个节点称为一个 Znode。 每个 Znode 由 3 部分组成:</p> <p>① stat：此为状态信息, 描述该 Znode 的版本, 权限等信息</p> <p>② data：与该 Znode 关联的数据</p> <p>③ children：该 Znode 下的子节点</p> <h3 id="_5-2-2-节点类型"><a href="#_5-2-2-节点类型" class="header-anchor">#</a> 5.2.2 节点类型</h3> <p>Znode 有 2 大类 4 小类, 两大类分别为永久节点和临时节点.</p> <p>⚪ 永久节点(Persistent): 客户端和服务器端断开连接后，创建的节点不会消失, 只有在客户端执行删除操作的时候, 他们才能被删除.</p> <p>⚪ 临时节点(Ephemeral): 客户端和服务器端断开连接后，创建的节点会被删除.</p> <p>Znode 还有一个序列化的特性, 这个序列号对于此节点的父节点来说是唯一的, 这样便会记录每个子节点创建的先后顺序. 它的格式为“%10d”(10 位数字, 没有数值的数位用 0 补充, 例如“0000000001”)，因此节点可以分为 4 小类:</p> <p>① 永久节点(Persistent)</p> <p>② 永久_序列化节点(Persistent_Sequential)</p> <p>③ 临时节点(Ephemeral)</p> <p>④ 临时_序列化节点(Ephemeral_Sequential)</p> <h2 id="_5-3-zookeeper-的-watch-监听机制"><a href="#_5-3-zookeeper-的-watch-监听机制" class="header-anchor">#</a> 5.3 Zookeeper 的 watch 监听机制</h2> <p>⚪ 在 ZooKeeper 中还支持一种 watch(监听)机制, 它允许对 ZooKeeper 注册监听, 当监听的对象发生指定的事件的时候, ZooKeeper 就会返回一个通知.</p> <p>⚪ Watcher 分为以下三个过程：客户端向 ZK 服务端注册 Watcher、服务端事件发生触发 Watcher、客户端回调 Watcher 得到触发事件情况. 触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。</p> <p>⚪ Watcher 是一次性的. 一旦被触发将会失效. 如果需要反复进行监听就需要反复进行注册</p> <h3 id="_5-3-1-监听器原理"><a href="#_5-3-1-监听器原理" class="header-anchor">#</a> 5.3.1 监听器原理</h3> <img src="/java/Snipaste_2023-09-08_14-17-49.png" alt="mixureSecure"> <p>① 首先要有一个 main()线程</p> <p>② 在 main 线程中创建 Zookeeper 客户端， 这时就会创建两个线程，一个复制网络连接通信(connect), 一个负责监听(listener).</p> <p>③ 通过 connect 线程将注册的监听事件发送给 zk, 常见的监听有</p> <p>​	监听节点数据的变化 get path [watch]</p> <p>​	监听节点状态的变化 stat path [watch]</p> <p>​	监听子节点增减的变化 ls path [watch]</p> <p>④ 将注册的监听事件添加到 zk 的注册的监听器列表中</p> <p>⑤ 监听到有数据或路径变化, 就会将这个消息发送给 listener 线程.</p> <p>⑥ listener 线程内部调用了 process()方法.此方法是程序员自定义的方法, 里面可以写明监听到事件后做如何的通知操作.</p> <h3 id="_5-3-2监听器实际应用"><a href="#_5-3-2监听器实际应用" class="header-anchor">#</a> 5.3.2监听器实际应用</h3> <p>监听器+ZK 临时节点能够很好的监听服务器的上线和下线</p> <p>第一步: 先想 zk 集群注册一个监听器, 监听某一个节点路径</p> <p>第二步: 主要服务器启动, 就去 zk 上指定路径下创建一个临时节点.</p> <p>第三步: 监听器监听 servers 下面的子节点有没有变化, 一旦有变化, 不管新增(机器上线)还是减少(机器下线)都会马上给对应的人发送通知</p> <h2 id="_5-4-zookeeper-的应用场景"><a href="#_5-4-zookeeper-的应用场景" class="header-anchor">#</a> 5.4 Zookeeper 的应用场景</h2> <p>​	ZK 提供的服务包括: 统一命名服务, 统一配置管理, 统一集群管理, 集群选主, 服务动态上下线, 分布式锁等.</p> <h3 id="_5-4-1-统一命名服务"><a href="#_5-4-1-统一命名服务" class="header-anchor">#</a> 5.4.1 统一命名服务</h3> <p>​	统一命名服务使用的是 ZK 的 node 节点全局唯一的这个特点.</p> <p>​	在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如：IP 不容易记住，而域名容易记住。创建一个节点后, 节点的路径就是全局唯一的, 可以作为全局名称使用.</p> <h3 id="_5-4-2-统一配置管理"><a href="#_5-4-2-统一配置管理" class="header-anchor">#</a> 5.4.2 统一配置管理</h3> <p>​	统一配置管理, 使用的是 Zookeeper 的 watch 机制</p> <p>⚪ 需求: 分布式环境下, 要求所有节点的配置信息是一致的, 比如Kafka 集群. 对配置文件修改后, 希望能够快速同步到各个节点上.</p> <p>⚪ 方案: 可以把所有的配置都放在一个配置中心, 然后各个服务分别去监听配置中心, 一旦发现里面的内容发生变化, 立即获取变化的内容, 然后更新本地配置即可.</p> <p>⚪ 实现: 配置管理可交由 Zookeeper 实现</p> <p>​	① 可将配置信息写入 Zookeeper 上的一个 Znode.</p> <p>​	② 各个客户端服务器监听这个 Znode.</p> <p>​	③ 一旦 Znode 中的数据被修改, Zookeeper 将通知各个客户端服务器.</p> <h1 id="springboot"><a href="#springboot" class="header-anchor">#</a> SpringBoot</h1> <h2 id="_6-1-springboot-是什么"><a href="#_6-1-springboot-是什么" class="header-anchor">#</a> 6.1 SpringBoot 是什么</h2> <p>​	是 Spring 的子项目,主要简化 Spring 开发难度,去掉了繁重配置,提供各种启动器,可以让程序员很快上手,节省开发时间.</p> <h2 id="_6-2-springboot-的优点"><a href="#_6-2-springboot-的优点" class="header-anchor">#</a> 6.2 SpringBoot 的优点</h2> <p>​	SpringBoot 对上述 Spring 的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p> <p>​	<strong>版本锁定</strong>：解决是 maven 依赖版本容易冲突的问题，集合了常用的并且测试过的所有版本使用了 Starter（启动器）管理依赖并能对版本进行集中控制,如下的父工程带有版本号, 就是对版本进行了集中控制</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token comment">&lt;!--引入父工程--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.0.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>起步依赖</strong> ：解决了完成某一个功能要整合的 jar 包过多的问题，集合了常用的jar 包</p> <p><strong>自动配置</strong>：解决了整合框架或者技术的配置文件过多，集合了所有的约定的默认配置内置 Tomcat：通过内置的 tomcat，无需再用其他外置的 Tomcat 就直接可以运行javaEE程序</p> <p><strong>总之</strong>：人们把 Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的 spring 项目，并且尽可能的减少一切 xml 配置，做到开箱即用，迅速上手，让我们关注与业务而非配置</p> <h2 id="_6-3-运行-springboot-项目的方式"><a href="#_6-3-运行-springboot-项目的方式" class="header-anchor">#</a> 6.3 运行 SpringBoot 项目的方式</h2> <p>① 可以打包</p> <p>② 可以使用 Maven 插件直接运行.</p> <p>③ 直接运行 main 方法.</p> <h2 id="_6-4-springboot-的启动器-starte"><a href="#_6-4-springboot-的启动器-starte" class="header-anchor">#</a> 6.4 SpringBoot 的启动器 starte</h2> <h3 id="_1-什么是-starter"><a href="#_1-什么是-starter" class="header-anchor">#</a> (1)什么是 starter?</h3> <p>​	starter 启动器,可以通过启动器集成其他的技术,比如说: web, mybatis, redis 等等.可以提供对应技术的开发和运行环境. 比如: pom 中引入 spring-boot-starter-web, 就可以进行 web 开发.</p> <h3 id="_2-starter-执行原理"><a href="#_2-starter-执行原理" class="header-anchor">#</a> (2)starter 执行原理?</h3> <p>⚪ SpringBoot 在启动时候会去扫描 jar 包中的一个名为 spring.factories.</p> <p>⚪ 根据文件中的配置,去加载自动配置类. 配置文件格式是 key=value, value 中配置了很多需要 Spring 加载的类.</p> <p>⚪ Spring 会去加载这些自动配置类, Spring 读取后,就会创建这些类的对象,放到Spring容器中.后期就会从 Spring 容器中获取这些类对象.</p> <h3 id="_3-springboot-中常用的启动器"><a href="#_3-springboot-中常用的启动器" class="header-anchor">#</a> (3)SpringBoot 中常用的启动器</h3> <p>⚪ spring-boot-starter-web, 提供 web 技术支持</p> <p>⚪ spring-boot-starter-test</p> <p>⚪ spring-boot-starter-jdbc</p> <p>⚪spring-boot-starter-jpa</p> <p>⚪ spring-boot-starter-redis…等等</p> <h2 id="_6-5-springboot-运行原理剖析"><a href="#_6-5-springboot-运行原理剖析" class="header-anchor">#</a> 6.5 SpringBoot 运行原理剖析</h2> <p>(一) SpringApplication 类作用及 run()方法作用</p> <p>⚪ SpringApplication 这个类整合了其他框架的启动类, 只要运行这一个类,所有的整合就都完成了.</p> <p>⚪ 调 用 run 函 数 , 将 当 前 启 动 类 的 字 节 码 传 入 ( 主要目的是传入@SpringBootApplication 这个注解), 以及 main 函数的 args 参数.</p> <p>⚪ 通过获取当前启动类的核心信息, 创建 IOC 容器.</p> <p>(二) 当前启动类@SpringBootApplication 详细剖析</p> <p>​	run 函数传入的当前启动类字节码, 最重要的是传入了@SpringBootApplication, 点开该注解源码, 会发现有多个注解组成,接下来会详细解释每个注解的含义. 点开这个注解源码, 发现有 4 类注解.</p> <img src="/java/Snipaste_2023-09-08_17-11-27.png" alt="mixureSecure"> <p>​	(1) 第一类: JDK 原生注解 4 个</p> <p>​	@Target(ElementType.TYPE) //当前注解的使用范围</p> <p>​	@Retention(RetentionPolicy.RUNTIME) //生命周期</p> <p>​	@Documented //声明在生成 doc 文档时是否带着注解</p> <p>​	@Inherited //声明是否子类会显示父类的注解</p> <p>​	(2)第二类:</p> <p>​	@SpringBootConfiguration 点开该注解源码, 会发现本质是@Configuration,定义该类是个配置类功能等同于xml 配置文件.</p> <p>​	提到@Configuration 就要提到他的搭档@Bean, 使用这两个注解就可以创建一个简单的 Spring 配置类, 可以用来替代相应的 xml 配置文件.可以理解为创建了IOC 容器了.</p> <p>​	(3)第三类: @ComponentScan, 包扫描功能.</p> <p>​	这个注解对应 Spring 的 XML 配置中的@ComponentScan，其实就是自动扫描并加载符合条件的组件(比如@Component 和@Repository 等)或者 bean 定义, 最终将这些bean 定义加载到 IoC 容器中.</p> <p>​	也可以通过 basePackages 等属性来细粒度的定制@ComponentScan 自动扫描的范围, 如果不指定, 则默认扫描@ComponentScan 所在类的 package 及子包进行扫描。注：所以 SpringBoot 的启动类最好是放在 root package 下，因为默认不指定basePackages, 这样能扫描 root package 及子包下的所有类.</p> <p>​	(4)第四类:</p> <p>​	@EnableAutoConfiguration 点开源码会发现,本质是@import, 自动导入功能</p> <ol><li><p>@EnableAutoConfiguration 也是借助@Import 的帮助，将所有符合自动配置条件的 bean 定义加载到 IoC 容器. @EnableAutoConfiguration 会根据类路径中的 jar 依赖为项目进行自动配置, 如：添加了spring-boot-starter-web 依赖, 会自动添加 Tomcat 和 SpringMVC 的依赖, SpringBoot 会对 Tomcat 和 SpringMVC 进行自动配置.</p></li> <li><p>那么 SpringBoot 是如何完成自动配置的呢?</p> <p>A. SpringBoot 自动配置的注解是 @EnableAutoConfiguration.</p> <p>B. 我们用的时候是在启动类上加@SpringBootApplication,这个注解是复合注解,内部包含 @EnableAutoConfiguration</p> <p>C. @EnableAutoConfiguration 内部有一个@Import, 这个注解才是完成自动配置的关键.</p> <p>D. @Import 导入一个类(AutoConfigurationImportSelector),这个类内部提供了一个方法(selectImports). 这个方法会扫描导入的所有 jar 包下的 spring.factories 文件. 解析文件中自动配置类 key=value, 将列表中的类创建,并放到 Spring 容器中.</p></li></ol> <p><strong>总结</strong></p> <p>总之一个@SpringBootApplication 注解就搞定了所有事, 它封装了核心的@SpringBootConfiguration+@EnableAutoConfiguration+@ComponentScan这三个类,大大节省了程序员配置时间,这就是 SpringBoot 的核心设计思想.</p> <h2 id="_6-6-springboot-热部署"><a href="#_6-6-springboot-热部署" class="header-anchor">#</a> 6.6 SpringBoot 热部署</h2> <p>导入 spring-boot-devtools 这个 jar 包: 就可以完成热部署了.</p> <h2 id="_6-7-springboot-中的配置文件"><a href="#_6-7-springboot-中的配置文件" class="header-anchor">#</a> 6.7 SpringBoot 中的配置文件</h2> <p>(1)有哪些配置文件?</p> <p>application.yml 或 application.properties</p> <p>bootstrap.yml 或 bootstrap.properties</p> <p>(2)上面两种配置文件有什么区别?</p> <ol><li>bootstrap 由父 ApplicationContext 加载, 比 application 配置文件优先被加载.</li> <li>bootstarp 里的属性不能被覆盖.</li> <li>application: springboot 项目中的自动化配置.</li> <li>bootstrap: 使用 spring cloud config 配置中心时, 需要加载连接配置中心的配置属性的, 就可以使用 bootstrap 来完成. 加载不能被覆盖的属性. 加载一些加密/解密的数据</li></ol> <p>(3)读取配置文件的方式?</p> <p>​	<strong>读取默认配置文件</strong></p> <p>​	需要注入 Environment 类, 使用 environment.getProperty(peorperties 中的key), 这样就能获得 key 对应的 value 值 @value(${key.value}) 直接读取</p> <div class="language- extra-class"><pre><code>**读取自定义配置文件**
</code></pre></div><p>​	自定义配置文件后缀必须是.propeties</p> <p>​	编写和自定义配置文件对应的 java 类, 类上放3 个注解</p> <p>​	@ConfigurationProperties(“前缀”)</p> <p>​	@PropertySource(“指定配置文件”)</p> <p>​	@Component 包扫描  读取的时候就跟读取默认配置文件一样.</p> <h2 id="_6-8-springboot-支持哪些日志框架"><a href="#_6-8-springboot-支持哪些日志框架" class="header-anchor">#</a> 6.8 SpringBoot 支持哪些日志框架</h2> <p>Java Utils logging</p> <p>Log4j2</p> <p>Lockback</p> <p>如果你使用了启动器,那么 springboo 默认将 Lockback 作为日志框架.</p> <h2 id="_6-9-springboot-常用注解"><a href="#_6-9-springboot-常用注解" class="header-anchor">#</a> 6.9 SpringBoot 常用注解</h2> <p>① @SpringBootApplication: 它 封 装 了 核 心 的 @SpringBootConfiguration+@EnableAutoConfiguration +@ComponentScan 这三个类,大大节省了程序员配置时间,这就是 SpringBoot 的核心设计思想.</p> <p>② @EnableScheduling 是通过@Import 将 Spring 调度框架相关的bean 定义都加载到IoC 容器</p> <p>③ @MapperScan:spring-boot支持mybatis组件的一个注解，通过此注解指定mybatis接口类的路径，即可完成对 mybatis 接口的扫描</p> <p>④ @RestController 是 @Controller 和 @ResponseBody 的 结合, 一个类被加上@RestController 注解,数据接口中就不再需要添加@ResponseBody,更加简洁。</p> <p>⑤ @RequestMapping,我们都需要明确请求的路径.</p> <p>⑥ @GetMappping,@PostMapping, @PutMapping, @DeleteMapping 结合@RequestMapping 使用, 是 Rest 风格的, 指定更明确的子路径.</p> <p>⑦ @PathVariable：路径变量注解，用{}来定义 url 部分的变量名.</p> <p>⑧ @Service 这个注解用来标记业务层的组件，我们会将业务逻辑处理的类都会加上这个注解交给 spring 容器。事务的切面也会配置在这一层。当让 这个注解不是一定要用。有个泛指组件的注解，当我们不能确定具体作用的时候 可以用泛指组件的注解托付给spring 容器</p> <p>⑨ @Component 和 spring 的注解功能一样, 注入到 IOC 容器中.</p> <p>⑩ @ControllerAdvice 和 @ExceptionHandler 配合完成统一异常拦截处理.</p> <h1 id="_7-springcloud"><a href="#_7-springcloud" class="header-anchor">#</a> 7. SpringCloud</h1> <h2 id="_7-1-soa-和微服务的区别"><a href="#_7-1-soa-和微服务的区别" class="header-anchor">#</a> 7.1 SOA 和微服务的区别?</h2> <p>​	谈到 SOA 和微服务的区别, 那咱们先谈谈架构的演变</p> <ol><li><p><strong>集中式架构</strong></p> <p>项目功能简单, 一个项目只需一个应用, 将所有功能部署在一起, 这样的架构好处是减少了部署节点和成本. 缺点: 代码耦合，开发维护困难, 无法水平扩展, 单点容错率低，并发能力差</p></li> <li><p><strong>垂直拆分架构</strong></p> <p>当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分</p> <p>优点：  系统拆分实现了流量分担，解决了并发问题</p> <p>可以针对不同模块进行优化, 方便水平扩展，负载均衡，容错率提高</p> <p>缺点：系统间相互独立，会有很多重复开发工作，影响开发效率</p></li> <li><p><strong>分布式服务</strong></p> <p>当垂直应用越来越多, 随着项目业务功能越来越复杂, 并非垂直应用这一条线进行数据调用, 应用和应用之间也会互相调用, 也就是完成某一个功能,需要多个应用互相调用, 这就是将功能拆完来完成的分布式架构</p> <p>优点: 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</p> <p>缺点: 系统间耦合度变高，调用关系错综复杂，难以维护</p></li> <li><p><strong>服务治理架构 SOA</strong></p> <p>SOA ：面向服务的架构</p> <p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键, 而最初的服务治理基石是 Dubbo 服务治理</p></li></ol> <p>​	  <strong>以前分布式服务的问题？</strong></p> <p>​		① 服务越来越多，需要管理每个服务的地址, 调用关系错综复杂，难以理清依赖关系</p> <p>​		② 服务过多，服务状态难以管理，无法根据服务情况动态管理</p> <p>​	 <strong>SOA 服务治理架构的优点:</strong></p> <p>​		①  服务注册中心，实现服务自动注册和发现，无需人为记录服务地址</p> <p>​		② 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系</p> <p>​		③ 动态监控服务状态监控报告，人为控制服务状态</p> <p>​	<strong>SOA 服务治理架构的缺点</strong>：</p> <p>​		① 服务间依然会有依赖关系，一旦某个环节出错会影响较大(容错机制)</p> <p>​		② 服务关系复杂，运维、测试部署困难，不符合开发-运维一站式维护的思想.</p> <ol start="5"><li><p><strong>微服务</strong></p> <p>前面说的 SOA，英文翻译过来是面向服务。</p> <p>微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别： 微服务的特点：</p> <p><strong>单一职责</strong>：微服务中每一个服务都对应唯一的业务能力，做到单一职责.</p> <p><strong>微</strong>：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</p> <p><strong>面向服务</strong>：面向服务是说每个服务都要对外暴露 Rest 风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest 的接口即可。</p> <p><strong>自治</strong>：自治是说服务间互相独立，互不干扰</p> <p>​	团队独立：每个服务都是一个独立的开发团队，人数不能过多。</p> <p>​	技术独立：因为是面向服务，提供 Rest 接口，使用什么技术没有别人干涉 前后端分离：采用	前后端分离开发，提供统一 Rest 接口，后端不用再为PC、移动段开发不同接口</p> <p>​	数据库分离：每个服务都使用自己的数据源</p> <p>​	部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护. 基于 docker 容器是开发.</p></li></ol> <p><strong>目前微服务微服务架构主流的是 SpringBoot+Dubbo 和 SpringBoot+SpringCloud的架构模式. 综上, 无论是 SOA 还是微服务, 都需要进行服务调度, 目前主流的服务调度室RPC和HTTP 两种协议, 而 Dubbo 基于 RPC 的远程调度机构, SpringCloud 是基于Rest 风格(基于 http 协议实现的)的 Spring 全家桶微服务服务治理框架. 说到这里也可以继续说下Dubbo和 SpringCloud 的区别.</strong></p> <h2 id="_7-2-springcloud-是什么"><a href="#_7-2-springcloud-是什么" class="header-anchor">#</a> 7.2 SpringCloud 是什么?</h2> <p>​	SpringCloud 是一系列框架的集合，集成 SpringBoot，提供很多优秀服务：服务发现和注册，统一配置中心, 负载均衡，网关, 熔断器等的一个微服务治理框架</p> <h2 id="_7-3-springcloud-的优势"><a href="#_7-3-springcloud-的优势" class="header-anchor">#</a> 7.3 SpringCloud 的优势?</h2> <p>⚪ 因为 SpringCloud 源于 Spring，所以它的质量，稳定性，持续性都是可以保证的。</p> <p>⚪ SpringCloud 天热支持 SpringBoot 框架，就可以提高开发效率，能够实现需求。</p> <p>⚪ SpringCloud 更新很快，后期支持很给力。  SpringCloud 可以用来开发微服务</p> <h2 id="_7-4-springcloud-有哪些核心组件"><a href="#_7-4-springcloud-有哪些核心组件" class="header-anchor">#</a> 7.4 SpringCloud 有哪些核心组件?</h2> <p>① Eureka: 注册中心, 服务注册和发现</p> <p>② Ribbon: 负载均衡, 实现服务调用的负载均衡</p> <p>③ Hystrix: 熔断器</p> <p>④ Feign: 远程调用</p> <p>⑤ Gateway: 网关</p> <p>⑥ Spring Cloud Config: 配置中心</p> <p><strong>Eureka</strong></p> <p>提供服务注册和发现, 是注册中心. 有两个组件: Eureka 服务端和Eureka 客户端 Eureka 服务端: 作为服务的注册中心, 用来提供服务注册, 支持集群部署.  Eureka 客户端: 是一个 java 客户端, 将服务注册到服务端, 同事将服务端的信息缓存到本地, 客户端和服务端定时交互</p> <p>（1）原理</p> <img src="/java/Snipaste_2023-09-09_10-52-59.png" alt="mixureSecure"> <ul><li><p>Eureka-Server：就是服务注册中心（可以是一个集群），对外暴露自己的地址。</p></li> <li><p>提供者：启动后向 Eureka 注册自己信息（地址，服务名称等），并且定期进行服务续约</p></li> <li><p>消费者：服务调用方，会定期去 Eureka 拉取服务列表，然后使用负载均衡算法选出一个服务进行调用。</p></li> <li><p>心跳(续约)：提供者定期通过 http 方式向 Eureka 刷新自己的状态</p></li></ul> <p>（2）服务下线、失效剔除和自我保护</p> <ul><li>服务的注册和发现都是可控制的，可以关闭也可以开启。默认都是开启</li> <li>注册后需要心跳，心跳周期默认 30 秒一次，超过 90 秒没发心跳认为宕机</li> <li>服务拉取默认 30 秒拉取一次.</li> <li>Eureka 每个 60 秒会剔除标记为宕机的服务</li> <li>Eureka 会有自我保护，当心跳失败比例超过阈值(默认 85%)，那么开启自我保护，不再剔除服务。</li> <li>Eureka 高可用就是多台 Eureka 互相注册在对方上.</li></ul> <p><strong>Ribbon</strong></p> <ul><li>Ribbon 是 Netflix 发布的云中服务开源项目. 给客户端提供负载均衡, 也就是说Ribbon 是作用在消费者方的.</li> <li>简单来说, 它是一个客户端负载均衡器, 它会自动通过某种算法去分配你要连接的机器.</li> <li>SpringCloud 认为 Ribbon 这种功能很好, 就对它进行了封装, 从而完成负载均衡.</li> <li>Ribbon 默认负责均衡策略是轮询策略.</li></ul> <p><strong>Hystrix 熔断器</strong></p> <ul><li><p>有时候可能是网络问题, 一些其它问题, 导致代码无法正常运行, 这是服务就挂了, 崩溃了. 熔断器就是为了解决无法正常访问服务的时, 提供的一种解决方案.</p></li> <li><p>解决因为一个服务崩溃而引起的一系列问题, 使问题只局限于这个服务中,不会影响其他服务</p></li> <li><p>Hystrix 提供了两种功能, 一种是服务降级, 一种是服务熔断.</p></li></ul> <p>(1)  服务降级原理</p> <ul><li>Hystrix 为每个服务分配了小的线程池, 当用户发请求过来, 会通过线程池创建线程来执行任务, 当创建的线程池已满或者请求超时(这里和多线程线程池不一样,不存在任务队列), 则启动服务降级功能.</li> <li>降级指的请求故障时, 不会阻塞, 会返回一个友好提示(可以自定义, 例如网站维护中请稍后重试), 也就是说不会影响其他服务的运行.</li></ul> <p>(2)  服务熔断原理</p> <img src="/java/Snipaste_2023-09-09_10-58-41.png" alt="mixureSecure"> <p>状态机有 3 个状态：</p> <ul><li>Closed：关闭状态（断路器关闭），所有请求都正常访问。</li> <li>Open：打开状态（断路器打开），所有请求都会被降级。Hystix 会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是 50%，请求次数最少不低于 20 次。</li> <li>Half Open：半开状态，open 状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放 1 次请求通过，若这个请求是健康的，则会关闭断路器，否则继续保持打开，再次进行 5 秒休眠计时。</li></ul> <p><strong>Feign: 远程调用组件</strong></p> <ul><li>后台系统中, 微服务和微服务之间的调用可以通过 Feign 组件来完成.</li> <li>Feign 组件集成了 Ribbon 负载均衡策略(默认开启的, 使用轮询机制), Hystrix 熔断器(默认关闭的, 需要通过配置文件进行设置开启)</li> <li>被调用的微服务需要提供一个接口, 加上@@FeignClient(&quot;url&quot;)注解</li> <li>调用方需要在启动类上加上@EnableFeignClients, 开启 Feign 组件功能.</li></ul> <p><strong>Gateway: 路由/网关</strong></p> <ul><li><p>对于项目后台的微服务系统, 每一个微服务都不会直接暴露给用户来调用的, 但是如果用户知道了某一个服务的 ip:端口号:url:访问参数, 就能直接访问你. 如果再是恶意访问, 恶意攻击, 就会击垮后台微服务系统.因此, 需要一个看大门的大boss, 来保护我们的后台系统.</p></li> <li><p>Gateway 支持过滤器功能，对请求或响应进行拦截，完成一些通用操作。Gateway 提供两种过滤器方式：“pre”和“post”</p> <p>​	pre 过滤器，在转发之前执行，可以做参数校验、权限校验、流量监控、日志输出、协议转换等。</p> <p>​	post 过滤器，在后端微服务响应之后并且给前端响应之前执行，可以做响应内容、响应头的修改，日志的输出，流量监控等</p></li> <li><p>Gateway 还提供了两种类型过滤器</p></li></ul> <p>(1) GatewayFilter：局部过滤器，针对单个路由</p> <div class="language- extra-class"><pre><code>		1. GatewayFilter 局部过滤器，是针对单个路由的过滤器。
		1.  在 Spring Cloud Gateway 组件中提供了大量内置的局部过滤器，对请求和响应做过滤操作。
		1. 遵循约定大于配置的思想，只需要在配置文件配置局部过滤器名称，并为其指定对应的值，就可以让其生效.
</code></pre></div><p>(2) GlobalFilter ：全局过滤器，针对所有路由.</p> <ol><li>GlobalFilter 全局过滤器，不需要在配置文件中配置，系统初始化时加载，并作用在每个路由上。</li> <li>Spring Cloud Gateway 核心的功能也是通过内置的全局过滤器来完成。</li> <li>自定义全局过滤器步骤：
<ol><li>定义类实现 GlobalFilter 和 Ordered 接口</li> <li>复写方法</li> <li>完成逻辑处理</li></ol></li></ol> <p><strong>Spring Cloud Config</strong></p> <ul><li>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在 Spring Cloud 中，有分布式配置中心组件springCloud Config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git 仓库中.</li></ul> <h2 id="_7-5-springboot-和-springcloud-的关系"><a href="#_7-5-springboot-和-springcloud-的关系" class="header-anchor">#</a> <strong>7.5 SpringBoot 和 SpringCloud 的关系</strong></h2> <ul><li>SpringBoot 是为了解决 Spring 配置文件冗余问题, 简化开发的框架.</li> <li>SpringCloud 是为了解决微服务之间的协调和配置问题, 还有服务之间的通信, 熔断, 负载均衡远程调度任务框架.</li> <li>SpringCloud 需要依赖 SpringBoot 搭建微服务, SpringBoot 使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，SpringCloud很大的一部分是基于 SpringBoot 来实现。</li> <li>SpringBoot 不需要依赖 SpringCloud 就可以独立开发. SpringBoot 也可以集成Dubbo 进行开发</li></ul> <h2 id="_7-6-springcloud-和-dubbo-的区别"><a href="#_7-6-springcloud-和-dubbo-的区别" class="header-anchor">#</a> 7.6 SpringCloud 和 Dubbo 的区别</h2> <ul><li><p>SpringCloud 和 Dubbo 都是主流的微服务架构.</p></li> <li><p>SpringCloud 是 Apache 下的 Spring 体系下的微服务解决方案.</p></li> <li><p>Dubbo 是阿里系统中分布式微服务治理框架.</p></li> <li><p>技术方面对比</p> <ul><li>SpringCloud 功能远远超过 Dubbo, Dubbo 只实现了服务治理(注册和发现). 但是 SpringCloud 提供了很多功能, 有 21 个子项目</li> <li>Dubbo 可 以 使 用 Zookeeper 作 为 注 册 中 心 , 实 现服务的注册和发现, SpringCloud 不仅可以使用 Eureka 作为注册中心, 也可以使用Zookeeper 作为注册中心.</li> <li>Dubbo 没有实现网关功能, 只能通过第三方技术去整合. 但是SpringCloud有zuul 路由网关, 对请求进行负载均衡和分发. 提供熔断器, 而且和git 能完美集成.</li></ul></li> <li><p>性能方面对比</p> <ul><li>由于 Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于TCP 协议传输的，配合以 Hession 序列化完成 RPC。</li> <li>而 SpringCloud 是基于 Http 协议+Rest 接口调用远程过程的，相对来说，Http请求会有更大的报文，占的带宽也会更多。</li> <li>使用 Dubbo 时, 需要给每个实体类实现序列化接口, 将实体类转化为二进制进行RPC 通信调用.而使用 SpringCloud 时, 实体类就不需要进行序列化.</li></ul></li></ul> <h2 id="_7-6-eureka-和-zookeeper-的区别"><a href="#_7-6-eureka-和-zookeeper-的区别" class="header-anchor">#</a> 7.6 Eureka 和 Zookeeper 的区别</h2> <p>​	在谈这个问题前我们先看下 CAP 原则: C(Consistency)-数据一致性; A(Availability)- 服务可用性; P(Partition tolerance)-服务对网络分区故障的容错性, 这三个特性在任何分布式系统中不能同时满足, 最多同时满足两个, 而且 P(分区容错性)是一定要满足的.</p> <ul><li><p>Eureka 满足 AP(服务可用性和容错性), Zookeeper 满足 CP(数据一致性和容错性)</p></li> <li><p>Zookeeper 满足 CP, 数据一致性, 服务的容错性. 数据在各个服务间同步完成后才返回用户结果, 而且如果服务出现网络波动导致监听不到服务心跳, 会立即从服务列表中剔除, 服务不可用.</p></li> <li><p>Eureka 满足 AP, 可用性, 容错性. 当因网络故障时, Eureka 的自我保护机制不会立即剔除服务, 虽然用户获取到的服务不一定是可用的, 但至少能够获取到服务列表. 用户访问服务列表时还可以利用重试机制, 找到正确的服务. 更服务分布式服务的高可用需求.</p></li> <li><p>Eureka 集群各节点平等, Zookeeper 集群有主从之分.</p> <ul><li>如果 Zk 集群中有服务宕机,会重新进行选举机制,选择出主节点, 因此可能会导致整个集群因为选主而阻塞, 服务不可用.</li> <li>Eureka 集群中有服务宕机,因为是平等的各个服务器,所以其他服务器不受影响.</li></ul></li> <li><p>Eureka 的服务发现者会主动拉取服务, ZK 服务发现者是监听机制</p> <ul><li>Eureka 中获取服务列表后会缓存起来, 每隔 30 秒重新拉取服务列表.</li> <li>Zk 则是监听节点信息变化, 当服务节点信息变化时, 客户端立即就得到通知</li></ul></li></ul> <h1 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h1> <h2 id="_1-1-redis-是什么"><a href="#_1-1-redis-是什么" class="header-anchor">#</a> 1.1 Redis 是什么？</h2> <p>​	Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能非关系型（NoSQL）的（key-value）键值对数据库。可以用作数据库、缓存、消息中间件等。</p> <h2 id="_1-2-redis-的存储结构有哪些"><a href="#_1-2-redis-的存储结构有哪些" class="header-anchor">#</a> 1.2 Redis 的存储结构有哪些？</h2> <div class="language- extra-class"><pre><code>1. String，字符串，是 redis 的最基本的类型，一个 key 对应一个value。是二进制安全的，最大能存储 512MB。 
1. Hash，散列，是一个键值(key=&gt;value)对集合。string 类型的field 和value的映射表，特别适合用于存储对象。每个 hash 可以存储 232 -1 键值对（40 多亿）
1. List，列表，是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列边或者尾部（右边）。最多可存储 232 - 1 元素(4294967295, 每个列表可存储40 亿) 
1. Set，集合，是 string 类型的无序集合，最大的成员数为 232 -1(4294967295, 每个集合可存储 40 多亿个成员)。 
1. Sorted set，有序集合，和 set 一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。zset 的成员是唯一的,但分数(score)却可以重复。
</code></pre></div><h2 id="_1-3-redis-的优点"><a href="#_1-3-redis-的优点" class="header-anchor">#</a> 1.3 Redis 的优点？</h2> <div class="language- extra-class"><pre><code>1. 因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过10 万次读写操作，是已知性能最快的 Key-Value 数据库。Redis 支持事务 、持久化
1. 单线程操作，避免了频繁的上下文切换。 
1. 采用了非阻塞 I/O 多路复用机制。I/O 多路复用就是只有单个线程，通过跟踪每个 I/O 流的状态，来管理多个 I/O 流
</code></pre></div><h2 id="_1-4-为什么要用-redis"><a href="#_1-4-为什么要用-redis" class="header-anchor">#</a> 1.4 为什么要用 Redis</h2> <p>​	<strong>高性能：</strong> 假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p> <p>​	<strong>高并发：</strong> 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p> <h2 id="_1-5-redis-的持久化"><a href="#_1-5-redis-的持久化" class="header-anchor">#</a> 1.5 redis 的持久化</h2> <p>​	Redis 提供了两种持久化的方式，分别是 RDB（Redis DataBase）和AOF（AppendOnly File）。 	<strong>RDB</strong>，简而言之，就是在不同的时间点，将 redis 存储的数据生成快照并存储到磁盘等介质上。</p> <p>​	<strong>AOF</strong>，则是换了一个角度来实现持久化，那就是将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p> <p>​	RDB 和 AOF 两种方式也可以同时使用，在这种情况下，如果redis 重启的话，则会优先采用 AOF 方式来进行数据恢复，这是因为 AOF 方式的数据恢复完整度更高</p> <h2 id="_1-6-redis-的缺点"><a href="#_1-6-redis-的缺点" class="header-anchor">#</a> 1.6 Redis 的缺点</h2> <p><strong>1.6.1 缓存和数据库双写一致性问题</strong></p> <p>​	一致性的问题很常见，因为加入了缓存之后，请求是先从 redis 中查询，如果redis 中存在数据就不会走数据库了，如果不能保证缓存跟数据库的一致性就会导致请求获取到的数据不是最新的数据。</p> <p>​	解决方案：</p> <ol><li>编写删除缓存的接口，在更新数据库的同时，调用删除缓存的接口删除缓存中的数据。这么做会有耦合高以及调用接口失败的情况。</li> <li>消息队列：ActiveMQ，消息通知。</li></ol> <p><strong>1.6.2 缓存的并发竞争问题</strong></p> <p>​	并发竞争，指的是同时有多个子系统去 set 同一个 key 值。</p> <p>​	解决方案：</p> <ol><li>最简单的方式就是准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可</li></ol> <p><strong>1.6.3 缓存雪崩问题</strong></p> <p>​	缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p> <p>​	解决方案：</p> <ol><li>给缓存的失效时间，加上一个随机值，避免集体失效。</li> <li>使用互斥锁，但是该方案吞吐量明显下降了。</li> <li>搭建 redis 集群。</li></ol> <p><strong>1.6.4 缓存击穿问题</strong></p> <p>​	缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p> <p>​	解决方案：</p> <ol><li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了， 再去请求数据库。没得到锁，则休眠一段时间重试</li> <li>采用异步更新策略，无论 key 是否取到值，都直接返回， value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。</li></ol> <h2 id="_1-7-redis-集群"><a href="#_1-7-redis-集群" class="header-anchor">#</a> 1.7 Redis 集群</h2> <p><strong>1.7.1 主从复制</strong></p> <p><strong>主从复制原理</strong></p> <p>​		从服务器连接主服务器，发送 SYNC 命令。主服务器接收到 SYNC 命名后，开始执行BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令。主服务器BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令。从服务器收到快照文件后丢弃所有旧数据，载入收到的快照。主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令。</p> <p>​		从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令（从服务器初始化完成）。主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（从服务器初始化完成后的操作）。</p> <p><strong>优点</strong> 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。为了分载Master 的读操作压力，Slave 服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master 来完成 Slave 同样可以接受其它 Slaves 的连接和同步请求，这样可以有效的分载Master 的同步压力 Master Server 是以非阻塞的方式为 Slaves 提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。Slave Server 同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis 则返回同步之前的数据。</p> <p><strong>缺点</strong> Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</p> <p><strong>1.7.2 哨兵模式</strong></p> <p>​	当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。为此，Redis2.8 中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。哨兵的作用就是监控 Redis 系统的运行状况，它的功能包括以下两个。</p> <ol><li>监控主服务器和从服务器是否正常运行。</li> <li>主服务器出现故障时自动将从服务器转换为主服务器。</li></ol> <p><strong>哨兵的工作方式</strong></p> <p>​		每个 Sentinel （哨兵）进程以每秒钟一次的频率向整个集群中的Master 主服务器，Slave 从务器以及其他 Sentinel（哨兵）进程发送一个 PING 命令。如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。如果一个 Master 主服务器被标记为主观下线（SDOWN），则正在监视这个Master 主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认 Master 主服务器的确进入了主观下线状态。当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认 Master 主服务器进入了主观下线状态（SDOWN），则Master 主服务器会被标记为客观下线（ODOWN）。</p> <p>​		 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一 169 / 196 次的频率向集群中的所有 Master 主服务器，Slave 从服务器发送 INFO 命令。当Master 主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave 从服务器发送 INFO 命令的频率会从10 秒一次改为每秒一次。若没有足够数量的 Sentinel（哨兵）进程同意 Master 主服务器下线，Master 主服务器的客观下线状态就会被移除。若 Master 主服务器重新向 Sentinel （哨兵）进程发送 PING 命令返回有效回复，Master 主服务器的主观下线状态就会被移除。</p> <p><strong>优点</strong> 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。主从可以自动切换，系统更健壮，可用性更高。</p> <p><strong>缺点</strong> Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂</p> <p><strong>1.7.3 Redis-Cluster 集群</strong></p> <p>​		redis 的哨兵模式基本已经可以实现高可用，读写分离，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在 redis3.0 上加入了cluster 模式，实现的redis 的分布式存储，也就是说每台 redis 节点上存储不同的内容。Redis-Cluster 采用无中心结构,它的特点如下：</p> <p>​		所有的 redis 节点彼此互联(PING-PONG 机制),内部使用二进制协议优化传输速度和带宽。节点的 fail 是通过集群中超过半数的节点检测失效时才生效。客户端与redis 节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</p> <p><strong>工作方式</strong></p> <p>​		在 redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的取值范围是：0-16383。还有一个就是 cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis 会根据 crc16 的算法得出一个结果，然后把结果对16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。为了保证高可用，redis-cluster 集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点 A 和它的从节点A1 都宕机了，那么该集群就无法再提供服务了。</p> <h2 id="_1-8-redis-的分布式锁"><a href="#_1-8-redis-的分布式锁" class="header-anchor">#</a> <strong>1.8 Redis 的分布式锁</strong></h2> <p>​	Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p> <p>1&gt;安全特性：互斥访问，即永远只有一个 client 能拿到锁</p> <p>2&gt;避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的client crash 了或者出现了网络分区</p> <p>3&gt;容错性：只要大部分 Redis 节点存活就可以正常提供服务</p> <p><strong>Redis 实现分布式锁</strong></p> <p>​		Redis 为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis 的连接并不存在竞争关系 Redis 中可以使用 SETNX 命令实现分布式锁。</p> <p>​		当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则SETNX不做任何动作 		SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p> <p>​		返回值：设置成功，返回 1 。设置失败，返回 0 。</p> <p>​		使用 SETNX 完成同步锁的流程及事项如下：</p> <p>​		使用 SETNX 命令获取锁，若返回 0（key 已存在，锁已存在）则获取失败，反之获取成功</p> <p>​		为了防止获取锁后程序出现异常，导致其他线程/进程调用 SETNX 命令总是返回0 而进入死锁状态，需要为该 key 设置一个“合理”的过期时间</p> <p>​		释放锁，使用 DEL 命令将锁数据删除</p> <h1 id="rocketmq"><a href="#rocketmq" class="header-anchor">#</a> RocketMQ</h1> <h2 id="_2-1-消息中间件的区别"><a href="#_2-1-消息中间件的区别" class="header-anchor">#</a> 2.1 消息中间件的区别</h2> <table><thead><tr><th>MQ</th> <th>描述</th></tr></thead> <tbody><tr><td>RabbitMQ</td> <td>erlang开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致RabbitMQ的性能急剧下降，每秒可以处理几万到几十万条消息</td></tr> <tr><td>RocketMQ</td> <td>java开发，面向互联网集群化功能丰富，对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，每秒大概可以处理几十万条消息</td></tr> <tr><td>Kafka</td> <td>Scala开发，面向日志功能丰富，性能最高，当你的业务场景中，每秒消息数量没有呢么多的时候，Kafka的时延反而会比较高，所有Kafka不太适合在线业务场景</td></tr> <tr><td>ActiveMQ</td> <td>java开发，简单，稳定，性能不如前三个，小型系统用也是OK的，但是不推荐，推荐上面三个</td></tr></tbody></table> <h2 id="_2-2-为什么要使用-mq"><a href="#_2-2-为什么要使用-mq" class="header-anchor">#</a> 2.2 为什么要使用 MQ</h2> <p>​		因为项目比较大，做了分布式系统，所有远程服务调用请求都是同步执行经常出问题，所以引入了 mq</p> <table><thead><tr><th>作用</th> <th>描述</th></tr></thead> <tbody><tr><td>解耦</td> <td>系统耦合度降低，没有强依赖关系</td></tr> <tr><td>异步</td> <td>不需要同步执行的远程调用可以有效提高响应时间</td></tr> <tr><td>削峰</td> <td>请求达到峰值后，后端服务还可以保持固定的消费速率消费，不会被压垮</td></tr></tbody></table> <h2 id="_2-3-rocketmq-由哪些角色组成-每个角色作用和特点是什么"><a href="#_2-3-rocketmq-由哪些角色组成-每个角色作用和特点是什么" class="header-anchor">#</a> 2.3 RocketMQ 由哪些角色组成，每个角色作用和特点是什么？</h2> <p>​	<strong>生产者（Producer）</strong>：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</p> <p>​	<strong>消费者（Consumer）</strong>：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。</p> <p>​	<strong>消息服务器（Broker）</strong>：是消息存储中心，主要作用是接收来自Producer 的消息并存储， Consumer 从这里取得消息。</p> <p>​	<strong>名 称 服 务 器 （ NameServer ）</strong> ： 用 来 保 存 Broker 相 关 Topic 等元信息并给Producer ，提供 Consumer 查找 Broker 信息。</p> <h2 id="_2-4-rocketmq-消费模式有几种"><a href="#_2-4-rocketmq-消费模式有几种" class="header-anchor">#</a> 2.4 RocketMQ 消费模式有几种？</h2> <p>模型由 Consumer 决定，消费维度为 Topic。</p> <p><strong>集群消费</strong></p> <ol><li>一条消息只会被同 Group 中的一个 Consumer 消费</li> <li>多个 Group 同时消费一个 Topic 时，每个 Group 都会有一个Consumer 消费到数据</li></ol> <p><strong>广播消费</strong></p> <p>​	消息将对一 个 Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个 Consumer Group ，消息也会被 Consumer Group 中的每个Consumer 都消费一次。 黑</p> <h2 id="_2-5-rocketmq-如何做负载均衡"><a href="#_2-5-rocketmq-如何做负载均衡" class="header-anchor">#</a> 2.5 RocketMQ 如何做负载均衡？</h2> <p>通过 Topic 在多 Broker 中分布式存储实现。</p> <p><strong>(1)producer 端</strong></p> <p>​	发送端指定 message queue 发送消息到相应的 broker，来达到写入时的负载均衡</p> <ul><li><p>提升写入吞吐量，当多个 producer 同时向一个 broker 写入数据的时候，性能会下降</p></li> <li><p>消息分布在多 broker 中，为负载消费做准备</p></li> <li><p>默认策略是随机选择：</p></li> <li><p>producer 维护一个 index</p></li> <li><p>每次取节点会自增</p></li> <li><p>index 向所有 broker 个数取余</p></li> <li><p>自带容错策略</p></li> <li><p>其他实现：</p> <ul><li><p>SelectMessageQueueByHash</p></li> <li><p>hash 的是传入的 args</p></li> <li><p>SelectMessageQueueByRandom</p></li> <li><p>SelectMessageQueueByMachineRoom 没有实现</p> <p>也可以自定义实现 MessageQueueSelector 接口中的 select 方法MessageQueue select(final List mqs, final Message msg, final Object arg);</p></li></ul></li></ul> <p><strong>(2) consumer 端</strong></p> <p>采用的是平均分配算法来进行负载均衡。</p> <p><strong>其他负载均衡算法</strong></p> <p>平均分配策略(默认)(AllocateMessageQueueAveragely)</p> <p>环形分配策略(AllocateMessageQueueAveragelyByCircle)</p> <p>手动配置分配策略(AllocateMessageQueueByConfig)</p> <p>机房分配策略(AllocateMessageQueueByMachineRoom)</p> <p>一致性哈希分配策略(AllocateMessageQueueConsistentHash)</p> <p>靠近机房策略(AllocateMachineRoomNearby)</p> <p><strong>追问：当消费负载均衡 consumer 和 queue 不对等的时候会发生什么？</strong></p> <p>​		Consumer 和 queue 会优先平均分配，如果 Consumer 少于 queue 的个数，则会存在部分 Consumer 消费多个 queue 的情况，如果 Consumer 等于 queue 的个数，那就是一个 Consumer 消费一个 queue，如果 Consumer 个数大于 queue 的个数，那么会有部分 Consumer 空余出来，白白的浪费了。</p> <h2 id="_2-6-消息重复消费如何解决"><a href="#_2-6-消息重复消费如何解决" class="header-anchor">#</a> 2.6 消息重复消费如何解决？</h2> <p>影响消息正常发送和消费的重要原因是网络的不确定性</p> <p><strong>出现原因</strong></p> <p>​		正常情况下在 consumer 真正消费完消息后应该发送 ack，通知broker 该消息已正常消费，从 queue 中剔除</p> <p>​		当 ack 因为网络原因无法发送到 broker，broker 会认为词条消息没有被消费，此后会开启消息重投机制把消息再次投递到 consumer。</p> <p>​		消费模式：在 CLUSTERING 模式下，消息在 broker 中会保证相同 group 的consumer 消费一次，但是针对不同 group 的 consumer 会推送多次</p> <p><strong>解决方案</strong></p> <ul><li>数据库表：处理消息前，使用消息主键在表中带有约束的字段中insert</li> <li>Map：单机时可以使用 map 做限制，消费时查询当前消息id 是不是已经存在</li> <li>Redis：使用分布式锁</li></ul> <h2 id="_2-7-如何让-rocketmq-保证消息的顺序消费"><a href="#_2-7-如何让-rocketmq-保证消息的顺序消费" class="header-anchor">#</a> 2.7 如何让 RocketMQ 保证消息的顺序消费</h2> <p>​		你们线上业务用消息中间件的时候，是否需要保证消息的顺序性? 如果不需要保证消息顺序，为什么不需要?</p> <p>​		假如我有一个场景要保证消息的顺序，你们应该如何保证? 首先多个 queue 只能保证单个 queue 里的顺序，queue 是典型的FIFO，天然顺序。多个 queue 同时消费是无法绝对保证消息的有序性的。</p> <p>​		所以总结如下：同一 topic，同一个 QUEUE，发消息的时候一个线程去发送消息，消费的时候一个线程去消费一个 queue 里的消息。</p> <p>​		 <strong>追问：怎么保证消息发到同一个 queue？</strong></p> <p>​		Rocket MQ 给我们提供了 MessageQueueSelector 接口，可以自己重写里面的接口，实现自己的算法，举个最简单的例子：判断 i % 2 == 0，那就都放到queue1 里，否则放到 queue2 里。</p> <h2 id="_2-8-rocketmq-如何保证消息不丢失"><a href="#_2-8-rocketmq-如何保证消息不丢失" class="header-anchor">#</a> 2.8 RocketMQ 如何保证消息不丢失</h2> <p>首先在如下三个部分都可能会出现丢失消息的情况： Producer 端 Broker 端 Consumer 端</p> <p><strong>2.8.1 Producer 端如何保证消息不丢失</strong></p> <p>​		采取 send()同步发消息，发送结果是同步感知的。</p> <p>​		发送失败后可以重试，设置重试次数。默认 3 次。</p> <p>​		producer.setRetryTimesWhenSendFailed(10);</p> <p>​		集群部署，比如发送失败了的原因可能是当前 Broker 宕机了，重试的时候会发送到其他 Broker 上。</p> <p><strong>2.8.2 Broker 端如何保证消息不丢失</strong></p> <p>​		修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。 flushDiskType = SYNC_FLUSH 集群部署，主从模式，高可用。</p> <p><strong>2.8.3 Consumer 端如何保证消息不丢失</strong></p> <p>​		完全消费正常后在进行手动 ack 确认。</p> <h2 id="_2-9-rocketmq-的消息堆积如何处理"><a href="#_2-9-rocketmq-的消息堆积如何处理" class="header-anchor">#</a> 2.9 RocketMQ 的消息堆积如何处理</h2> <ol><li>如果可以添加消费者解决，就添加消费者的数据量.</li> <li>如果出现了 queue，但是消费者多的情况。可以使用准备一个临时的topic，同时创建一些 queue，在临时创建一个消费者来把这些消息转移到 topic 中，让消费者消费</li></ol> <h2 id="_2-10-rocketmq-如何实现分布式事务"><a href="#_2-10-rocketmq-如何实现分布式事务" class="header-anchor">#</a> 2.10 RocketMQ 如何实现分布式事务？</h2> <ol><li><p>生产者向 MQ 服务器发送 half 消息。</p></li> <li><p>half 消息发送成功后，MQ 服务器返回确认消息给生产者。</p></li> <li><p>生产者开始执行本地事务。</p></li> <li><p>根据本地事务执行的结果（UNKNOW、commit、rollback）向MQ Server 发送提交或回滚消息。</p></li> <li><p>如果错过了（可能因为网络异常、生产者突然宕机等导致的异常情况）提交/回滚消息，则 MQ 服务器将向同一组中的每个生产者发送回查消息以获取事务状态。</p></li> <li><p>回查生产者本地事物状态。</p></li> <li><p>生产者根据本地事务状态发送提交/回滚消息。</p></li> <li><p>MQ 服务器将丢弃回滚的消息，但已提交（进行过二次确认的 half 消息）的消息将投递给消费者进行消费。</p> <p><strong>Half Message ：</strong> 预 处 理 消 息 ， 当 broker 收 到 此 类 消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC 的消息消费队列中</p> <p>**检查事务状态：**Broker 会开启一个定时任务，消费 RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，Broker 会定时去回调在重新检查。</p> <p>**超时：**如果超过回查次数，默认回滚消息。 也就是他并未真正进入 Topic 的 queue，而是用了临时 queue 来放所谓的half message，等提交事务后才会真正的将 half message 转移到 topic 下的 queue。</p> <h2 id="_2-11-任何一台-broker-突然宕机了怎么办"><a href="#_2-11-任何一台-broker-突然宕机了怎么办" class="header-anchor">#</a> 2.11 任何一台 Broker 突然宕机了怎么办？</h2> <p>​		Broker 主从架构以及多副本策略。Master 收到消息后会同步给Slave，这样一条消息就不止一份了，Master 宕机了还有 slave 中的消息可用，保证了 MQ 的可靠性和高可用性。而且 Rocket MQ4.5.0 开始就支持了 Dlegder 模式，基于 raft 的，做到了真正意义的HA</p></li></ol> <h1 id="mongodb"><a href="#mongodb" class="header-anchor">#</a> MongoDb</h1> <p>3.1 MongoDB 是什么？ mongodb 是属于文档型的非关系型数据库，是开源、高性能、高可用、可扩展的数据逻辑层次关系：文档=&gt;集合=&gt;数据库 在关系型数据库中每一行的数据对应 mongodb 里是一个文档。mongodb的文档是以 BSON（binary json）格式存储的，其格式就是 json 格式。</p> <img src="/java/Snipaste_2023-09-09_23-45-44.png" alt="mixureSecure"></div></div>  <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/09/07, 14:39:59</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/interview/ui/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">前端八股文</div></a> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/interview/ui/" class="prev">前端八股文</a></span> <!----></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:1539171422@foxmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/luyness" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2020-2023
    <span>luyn12</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9ad9824d.js" defer></script><script src="/assets/js/2.84b87111.js" defer></script><script src="/assets/js/107.0e050a3c.js" defer></script>
  </body>
</html>
